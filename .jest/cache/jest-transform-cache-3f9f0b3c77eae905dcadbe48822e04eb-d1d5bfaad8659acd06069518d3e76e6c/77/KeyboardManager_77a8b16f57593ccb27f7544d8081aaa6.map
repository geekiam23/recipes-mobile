{"version":3,"sources":["KeyboardManager.tsx"],"names":["React","componentWillUnmount","clearTimeout","input","TextInput","Date","force","Keyboard","setTimeout","render","onPageChangeStart","onPageChangeConfirm","onPageChangeCancel","handlePageChangeCancel"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard, HostComponent } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: (force: boolean) => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\ntype InputRef = React.ElementRef<HostComponent<unknown>> | undefined;\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: InputRef = undefined;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: blurTextInput accepts both number and ref, but types say only ref\n    const input: InputRef = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = (force: boolean) => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    if (force) {\n      // Always dismiss input, even if we don't have a ref to it\n      // We might not have the ref if onPageChangeStart was never called\n      // This can happen if page change was not from a gesture\n      Keyboard.dismiss();\n    } else {\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // Dismiss the keyboard only if an input was a focused before\n        // This makes sure we don't dismiss input on going back and focusing an input\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = undefined;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = undefined;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = undefined;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]}