{"version":3,"sources":["text.js"],"names":["Object","defineProperty","exports","value","findByText","findAllByText","getAllByText","getByText","queryAllByText","queryByText","_queryHelpers","require","_helpers","_shared","_allUtils","container","text","selector","exact","collapseWhitespace","trim","ignore","DEFAULT_IGNORE_TAGS","normalizer","checkContainerType","matcher","matches","fuzzyMatches","matchNormalizer","makeNormalizer","baseArray","Array","from","querySelectorAll","filter","node","getNodeText","getMultipleError","c","getMissingError","queryAllByTextWithSuggestions","wrapAllByQueryWithSuggestion","name","buildQueries"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findByText = exports.findAllByText = exports.getAllByText = exports.getByText = exports.queryAllByText = exports.queryByText = void 0;\n\nvar _queryHelpers = require(\"../query-helpers\");\n\nvar _helpers = require(\"../helpers\");\n\nvar _shared = require(\"../shared\");\n\nvar _allUtils = require(\"./all-utils\");\n\nconst queryAllByText = (container, text, {\n  selector = '*',\n  exact = true,\n  collapseWhitespace,\n  trim,\n  ignore = _shared.DEFAULT_IGNORE_TAGS,\n  normalizer\n} = {}) => {\n  (0, _helpers.checkContainerType)(container);\n  const matcher = exact ? _allUtils.matches : _allUtils.fuzzyMatches;\n  const matchNormalizer = (0, _allUtils.makeNormalizer)({\n    collapseWhitespace,\n    trim,\n    normalizer\n  });\n  let baseArray = [];\n\n  if (typeof container.matches === 'function' && container.matches(selector)) {\n    baseArray = [container];\n  }\n\n  return [...baseArray, ...Array.from(container.querySelectorAll(selector))] // TODO: `matches` according lib.dom.d.ts can get only `string` but according our code it can handle also boolean :)\n  .filter(node => !ignore || !node.matches(ignore)).filter(node => matcher((0, _allUtils.getNodeText)(node), node, text, matchNormalizer));\n};\n\nconst getMultipleError = (c, text) => `Found multiple elements with the text: ${text}`;\n\nconst getMissingError = (c, text) => `Unable to find an element with the text: ${text}. This could be because the text is broken up by multiple elements. In this case, you can provide a function for your text matcher to make your matcher more flexible.`;\n\nconst queryAllByTextWithSuggestions = (0, _queryHelpers.wrapAllByQueryWithSuggestion)(queryAllByText, queryAllByText.name, 'queryAll');\nexports.queryAllByText = queryAllByTextWithSuggestions;\nconst [queryByText, getAllByText, getByText, findAllByText, findByText] = (0, _allUtils.buildQueries)(queryAllByText, getMultipleError, getMissingError);\nexports.findByText = findByText;\nexports.findAllByText = findAllByText;\nexports.getByText = getByText;\nexports.getAllByText = getAllByText;\nexports.queryByText = queryByText;"]}