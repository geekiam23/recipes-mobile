123891bc5c6661f9c6c1d281b272e2b5
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForElementToBeRemoved = waitForElementToBeRemoved;

var _waitFor = require("./wait-for");

var isRemoved = function isRemoved(result) {
  return !result || Array.isArray(result) && !result.length;
};

function initialCheck(elements) {
  if (isRemoved(elements)) {
    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');
  }
}

function waitForElementToBeRemoved(callback, options) {
  var timeoutError, elements, getRemainingElements;
  return _regenerator.default.async(function waitForElementToBeRemoved$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          timeoutError = new Error('Timed out in waitForElementToBeRemoved.');

          if (typeof callback !== 'function') {
            initialCheck(callback);
            elements = Array.isArray(callback) ? callback : [callback];
            getRemainingElements = elements.map(function (element) {
              var parent = element.parentElement;
              if (parent === null) return function () {
                return null;
              };

              while (parent.parentElement) {
                parent = parent.parentElement;
              }

              return function () {
                return parent.contains(element) ? element : null;
              };
            });

            callback = function callback() {
              return getRemainingElements.map(function (c) {
                return c();
              }).filter(Boolean);
            };
          }

          initialCheck(callback());
          return _context.abrupt("return", (0, _waitFor.waitFor)(function () {
            var result;

            try {
              result = callback();
            } catch (error) {
              if (error.name === 'TestingLibraryElementError') {
                return undefined;
              }

              throw error;
            }

            if (!isRemoved(result)) {
              throw timeoutError;
            }

            return undefined;
          }, options));

        case 4:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, null, Promise);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndhaXQtZm9yLWVsZW1lbnQtdG8tYmUtcmVtb3ZlZC5qcyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQiLCJfd2FpdEZvciIsInJlcXVpcmUiLCJpc1JlbW92ZWQiLCJyZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJpbml0aWFsQ2hlY2siLCJlbGVtZW50cyIsIkVycm9yIiwiY2FsbGJhY2siLCJvcHRpb25zIiwidGltZW91dEVycm9yIiwiZ2V0UmVtYWluaW5nRWxlbWVudHMiLCJtYXAiLCJlbGVtZW50IiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImNvbnRhaW5zIiwiYyIsImZpbHRlciIsIkJvb2xlYW4iLCJ3YWl0Rm9yIiwiZXJyb3IiLCJuYW1lIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkMsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFDM0NDLEVBQUFBLEtBQUssRUFBRTtBQURvQyxDQUE3QztBQUdBRCxPQUFPLENBQUNFLHlCQUFSLEdBQW9DQSx5QkFBcEM7O0FBRUEsSUFBSUMsUUFBUSxHQUFHQyxPQUFPLGNBQXRCOztBQUVBLElBQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQUFDLE1BQU07QUFBQSxTQUFJLENBQUNBLE1BQUQsSUFBV0MsS0FBSyxDQUFDQyxPQUFOLENBQWNGLE1BQWQsS0FBeUIsQ0FBQ0EsTUFBTSxDQUFDRyxNQUFoRDtBQUFBLENBQXhCOztBQUlBLFNBQVNDLFlBQVQsQ0FBc0JDLFFBQXRCLEVBQWdDO0FBQzlCLE1BQUlOLFNBQVMsQ0FBQ00sUUFBRCxDQUFiLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBSUMsS0FBSixDQUFVLG9LQUFWLENBQU47QUFDRDtBQUNGOztBQUVELFNBQWVWLHlCQUFmLENBQXlDVyxRQUF6QyxFQUFtREMsT0FBbkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRVFDLFVBQUFBLFlBRlIsR0FFdUIsSUFBSUgsS0FBSixDQUFVLHlDQUFWLENBRnZCOztBQUlFLGNBQUksT0FBT0MsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ0gsWUFBQUEsWUFBWSxDQUFDRyxRQUFELENBQVo7QUFDTUYsWUFBQUEsUUFGNEIsR0FFakJKLEtBQUssQ0FBQ0MsT0FBTixDQUFjSyxRQUFkLElBQTBCQSxRQUExQixHQUFxQyxDQUFDQSxRQUFELENBRnBCO0FBRzVCRyxZQUFBQSxvQkFINEIsR0FHTEwsUUFBUSxDQUFDTSxHQUFULENBQWEsVUFBQUMsT0FBTyxFQUFJO0FBQ25ELGtCQUFJQyxNQUFNLEdBQUdELE9BQU8sQ0FBQ0UsYUFBckI7QUFDQSxrQkFBSUQsTUFBTSxLQUFLLElBQWYsRUFBcUIsT0FBTztBQUFBLHVCQUFNLElBQU47QUFBQSxlQUFQOztBQUVyQixxQkFBT0EsTUFBTSxDQUFDQyxhQUFkO0FBQTZCRCxnQkFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNDLGFBQWhCO0FBQTdCOztBQUVBLHFCQUFPO0FBQUEsdUJBQU1ELE1BQU0sQ0FBQ0UsUUFBUCxDQUFnQkgsT0FBaEIsSUFBMkJBLE9BQTNCLEdBQXFDLElBQTNDO0FBQUEsZUFBUDtBQUNELGFBUDRCLENBSEs7O0FBWWxDTCxZQUFBQSxRQUFRLEdBQUc7QUFBQSxxQkFBTUcsb0JBQW9CLENBQUNDLEdBQXJCLENBQXlCLFVBQUFLLENBQUM7QUFBQSx1QkFBSUEsQ0FBQyxFQUFMO0FBQUEsZUFBMUIsRUFBbUNDLE1BQW5DLENBQTBDQyxPQUExQyxDQUFOO0FBQUEsYUFBWDtBQUNEOztBQUVEZCxVQUFBQSxZQUFZLENBQUNHLFFBQVEsRUFBVCxDQUFaO0FBbkJGLDJDQW9CUyxDQUFDLEdBQUdWLFFBQVEsQ0FBQ3NCLE9BQWIsRUFBc0IsWUFBTTtBQUNqQyxnQkFBSW5CLE1BQUo7O0FBRUEsZ0JBQUk7QUFDRkEsY0FBQUEsTUFBTSxHQUFHTyxRQUFRLEVBQWpCO0FBQ0QsYUFGRCxDQUVFLE9BQU9hLEtBQVAsRUFBYztBQUNkLGtCQUFJQSxLQUFLLENBQUNDLElBQU4sS0FBZSw0QkFBbkIsRUFBaUQ7QUFDL0MsdUJBQU9DLFNBQVA7QUFDRDs7QUFFRCxvQkFBTUYsS0FBTjtBQUNEOztBQUVELGdCQUFJLENBQUNyQixTQUFTLENBQUNDLE1BQUQsQ0FBZCxFQUF3QjtBQUN0QixvQkFBTVMsWUFBTjtBQUNEOztBQUVELG1CQUFPYSxTQUFQO0FBQ0QsV0FsQk0sRUFrQkpkLE9BbEJJLENBcEJUOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLndhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgPSB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkO1xuXG52YXIgX3dhaXRGb3IgPSByZXF1aXJlKFwiLi93YWl0LWZvclwiKTtcblxuY29uc3QgaXNSZW1vdmVkID0gcmVzdWx0ID0+ICFyZXN1bHQgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpICYmICFyZXN1bHQubGVuZ3RoOyAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCBpcyBub3QgcHJlc2VudC5cbi8vIEFzIHRoZSBuYW1lIGltcGxpZXMsIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgc2hvdWxkIGNoZWNrIGBwcmVzZW50YCAtLT4gYHJlbW92ZWRgXG5cblxuZnVuY3Rpb24gaW5pdGlhbENoZWNrKGVsZW1lbnRzKSB7XG4gIGlmIChpc1JlbW92ZWQoZWxlbWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZWxlbWVudChzKSBnaXZlbiB0byB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkIGFyZSBhbHJlYWR5IHJlbW92ZWQuIHdhaXRGb3JFbGVtZW50VG9CZVJlbW92ZWQgcmVxdWlyZXMgdGhhdCB0aGUgZWxlbWVudChzKSBleGlzdChzKSBiZWZvcmUgd2FpdGluZyBmb3IgcmVtb3ZhbC4nKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yRWxlbWVudFRvQmVSZW1vdmVkKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZWQgaGVyZSBzbyB3ZSBnZXQgYSBuaWNlIHN0YWNrdHJhY2VcbiAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKCdUaW1lZCBvdXQgaW4gd2FpdEZvckVsZW1lbnRUb0JlUmVtb3ZlZC4nKTtcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5pdGlhbENoZWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IEFycmF5LmlzQXJyYXkoY2FsbGJhY2spID8gY2FsbGJhY2sgOiBbY2FsbGJhY2tdO1xuICAgIGNvbnN0IGdldFJlbWFpbmluZ0VsZW1lbnRzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4ge1xuICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHJldHVybiAoKSA9PiBudWxsO1xuXG4gICAgICB3aGlsZSAocGFyZW50LnBhcmVudEVsZW1lbnQpIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXG4gICAgICByZXR1cm4gKCkgPT4gcGFyZW50LmNvbnRhaW5zKGVsZW1lbnQpID8gZWxlbWVudCA6IG51bGw7XG4gICAgfSk7XG5cbiAgICBjYWxsYmFjayA9ICgpID0+IGdldFJlbWFpbmluZ0VsZW1lbnRzLm1hcChjID0+IGMoKSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9XG5cbiAgaW5pdGlhbENoZWNrKGNhbGxiYWNrKCkpO1xuICByZXR1cm4gKDAsIF93YWl0Rm9yLndhaXRGb3IpKCgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnVGVzdGluZ0xpYnJhcnlFbGVtZW50RXJyb3InKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIGlmICghaXNSZW1vdmVkKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IHRpbWVvdXRFcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LCBvcHRpb25zKTtcbn1cbi8qXG5lc2xpbnRcbiAgcmVxdWlyZS1hd2FpdDogXCJvZmZcIlxuKi8iXX0=