b7ece87bc9e3c2bae44ea290d1912a97
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _require = require("./intercepted_request_router"),
    InterceptedRequestRouter = _require.InterceptedRequestRouter;

var common = require("./common");

var _require2 = require('util'),
    inherits = _require2.inherits;

var http = require('http');

var debug = require('debug')('nock.intercept');

var globalEmitter = require("./global_emitter");

function NetConnectNotAllowedError(host, path) {
  Error.call(this);
  this.name = 'NetConnectNotAllowedError';
  this.code = 'ENETUNREACH';
  this.message = "Nock: Disallowed net connect for \"" + host + path + "\"";
  Error.captureStackTrace(this, this.constructor);
}

inherits(NetConnectNotAllowedError, Error);
var allInterceptors = {};
var allowNetConnect;

function enableNetConnect(matcher) {
  if (typeof matcher === 'string') {
    allowNetConnect = new RegExp(matcher);
  } else if (matcher instanceof RegExp) {
    allowNetConnect = matcher;
  } else if (typeof matcher === 'function') {
    allowNetConnect = {
      test: matcher
    };
  } else {
    allowNetConnect = /.*/;
  }
}

function isEnabledForNetConnect(options) {
  common.normalizeRequestOptions(options);
  var enabled = allowNetConnect && allowNetConnect.test(options.host);
  debug('Net connect', enabled ? '' : 'not', 'enabled for', options.host);
  return enabled;
}

function disableNetConnect() {
  allowNetConnect = undefined;
}

function isOn() {
  return !isOff();
}

function isOff() {
  return process.env.NOCK_OFF === 'true';
}

function addInterceptor(key, interceptor, scope, scopeOptions, host) {
  if (!(key in allInterceptors)) {
    allInterceptors[key] = {
      key: key,
      interceptors: []
    };
  }

  interceptor.__nock_scope = scope;
  interceptor.__nock_scopeKey = key;
  interceptor.__nock_scopeOptions = scopeOptions;
  interceptor.__nock_scopeHost = host;
  interceptor.interceptionCounter = 0;
  if (scopeOptions.allowUnmocked) allInterceptors[key].allowUnmocked = true;
  allInterceptors[key].interceptors.push(interceptor);
}

function remove(interceptor) {
  if (interceptor.__nock_scope.shouldPersist() || --interceptor.counter > 0) {
    return;
  }

  var basePath = interceptor.basePath;
  var interceptors = allInterceptors[basePath] && allInterceptors[basePath].interceptors || [];
  interceptors.some(function (thisInterceptor, i) {
    return thisInterceptor === interceptor ? interceptors.splice(i, 1) : false;
  });
}

function removeAll() {
  Object.keys(allInterceptors).forEach(function (key) {
    allInterceptors[key].interceptors.forEach(function (interceptor) {
      interceptor.scope.keyedInterceptors = {};
    });
  });
  allInterceptors = {};
}

function interceptorsFor(options) {
  common.normalizeRequestOptions(options);
  debug('interceptors for %j', options.host);
  var basePath = options.proto + "://" + options.host;
  debug('filtering interceptors for basepath', basePath);

  for (var _i = 0, _Object$values = Object.values(allInterceptors); _i < _Object$values.length; _i++) {
    var _ref = _Object$values[_i];
    var key = _ref.key;
    var interceptors = _ref.interceptors;
    var allowUnmocked = _ref.allowUnmocked;

    for (var _iterator = _createForOfIteratorHelperLoose(interceptors), _step; !(_step = _iterator()).done;) {
      var interceptor = _step.value;
      var filteringScope = interceptor.__nock_scopeOptions.filteringScope;

      if (filteringScope && filteringScope(basePath)) {
        interceptor.scope.logger('found matching scope interceptor');
        interceptors.forEach(function (ic) {
          ic.__nock_filteredScope = ic.__nock_scopeKey;
        });
        return interceptors;
      }
    }

    if (common.matchStringOrRegexp(basePath, key)) {
      if (allowUnmocked && interceptors.length === 0) {
        debug('matched base path with allowUnmocked (no matching interceptors)');
        return [{
          options: {
            allowUnmocked: true
          },
          matchOrigin: function matchOrigin() {
            return false;
          }
        }];
      } else {
        debug("matched base path (" + interceptors.length + " interceptor" + (interceptors.length > 1 ? 's' : '') + ")");
        return interceptors;
      }
    }
  }

  return undefined;
}

function removeInterceptor(options) {
  var Interceptor = require("./interceptor");

  var baseUrl, key, method, proto;

  if (options instanceof Interceptor) {
    baseUrl = options.basePath;
    key = options._key;
  } else {
    proto = options.proto ? options.proto : 'http';
    common.normalizeRequestOptions(options);
    baseUrl = proto + "://" + options.host;
    method = options.method && options.method.toUpperCase() || 'GET';
    key = method + " " + baseUrl + (options.path || '/');
  }

  if (allInterceptors[baseUrl] && allInterceptors[baseUrl].interceptors.length > 0) {
    for (var i = 0; i < allInterceptors[baseUrl].interceptors.length; i++) {
      var interceptor = allInterceptors[baseUrl].interceptors[i];

      if (interceptor._key === key) {
        allInterceptors[baseUrl].interceptors.splice(i, 1);
        interceptor.scope.remove(key, interceptor);
        break;
      }
    }

    return true;
  }

  return false;
}

var originalClientRequest;

function ErroringClientRequest(error) {
  http.OutgoingMessage.call(this);
  process.nextTick(function () {
    this.emit('error', error);
  }.bind(this));
}

inherits(ErroringClientRequest, http.ClientRequest);

function overrideClientRequest() {
  debug('Overriding ClientRequest');

  function OverriddenClientRequest() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _common$normalizeClie = common.normalizeClientRequestArgs.apply(common, args),
        options = _common$normalizeClie.options,
        callback = _common$normalizeClie.callback;

    if (Object.keys(options).length === 0) {
      throw Error('Creating a ClientRequest with empty `options` is not supported in Nock');
    }

    http.OutgoingMessage.call(this);
    var interceptors = interceptorsFor(options);

    if (isOn() && interceptors) {
      debug('using', interceptors.length, 'interceptors');
      var overrider = new InterceptedRequestRouter({
        req: this,
        options: options,
        interceptors: interceptors
      });
      (0, _extends2.default)(this, overrider);

      if (callback) {
        this.once('response', callback);
      }
    } else {
      debug('falling back to original ClientRequest');

      if (isOff() || isEnabledForNetConnect(options)) {
        originalClientRequest.apply(this, arguments);
      } else {
        common.setImmediate(function () {
          var error = new NetConnectNotAllowedError(options.host, options.path);
          this.emit('error', error);
        }.bind(this));
      }
    }
  }

  inherits(OverriddenClientRequest, http.ClientRequest);
  originalClientRequest = http.ClientRequest;
  http.ClientRequest = OverriddenClientRequest;
  debug('ClientRequest overridden');
}

function restoreOverriddenClientRequest() {
  debug('restoring overridden ClientRequest');

  if (!originalClientRequest) {
    debug('- ClientRequest was not overridden');
  } else {
    http.ClientRequest = originalClientRequest;
    originalClientRequest = undefined;
    debug('- ClientRequest restored');
  }
}

function isActive() {
  return originalClientRequest !== undefined;
}

function interceptorScopes() {
  var _ref2;

  var nestedInterceptors = Object.values(allInterceptors).map(function (i) {
    return i.interceptors;
  });
  return (_ref2 = []).concat.apply(_ref2, (0, _toConsumableArray2.default)(nestedInterceptors)).map(function (i) {
    return i.scope;
  });
}

function isDone() {
  return interceptorScopes().every(function (scope) {
    return scope.isDone();
  });
}

function pendingMocks() {
  var _ref3;

  return (_ref3 = []).concat.apply(_ref3, (0, _toConsumableArray2.default)(interceptorScopes().map(function (scope) {
    return scope.pendingMocks();
  })));
}

function activeMocks() {
  var _ref4;

  return (_ref4 = []).concat.apply(_ref4, (0, _toConsumableArray2.default)(interceptorScopes().map(function (scope) {
    return scope.activeMocks();
  })));
}

function activate() {
  if (originalClientRequest) {
    throw new Error('Nock already active');
  }

  overrideClientRequest();
  common.overrideRequests(function (proto, overriddenRequest, args) {
    var _common$normalizeClie2 = common.normalizeClientRequestArgs.apply(common, (0, _toConsumableArray2.default)(args)),
        options = _common$normalizeClie2.options,
        callback = _common$normalizeClie2.callback;

    if (Object.keys(options).length === 0) {
      throw Error('Making a request with empty `options` is not supported in Nock');
    }

    options.proto = proto;
    var interceptors = interceptorsFor(options);

    if (isOn() && interceptors) {
      var matches = interceptors.some(function (interceptor) {
        return interceptor.matchOrigin(options);
      });
      var allowUnmocked = interceptors.some(function (interceptor) {
        return interceptor.options.allowUnmocked;
      });

      if (!matches && allowUnmocked) {
        var req;

        if (proto === 'https') {
          var ClientRequest = http.ClientRequest;
          http.ClientRequest = originalClientRequest;
          req = overriddenRequest(options, callback);
          http.ClientRequest = ClientRequest;
        } else {
          req = overriddenRequest(options, callback);
        }

        globalEmitter.emit('no match', req);
        return req;
      }

      return new http.ClientRequest(options, callback);
    } else {
      globalEmitter.emit('no match', options);

      if (isOff() || isEnabledForNetConnect(options)) {
        return overriddenRequest(options, callback);
      } else {
        var error = new NetConnectNotAllowedError(options.host, options.path);
        return new ErroringClientRequest(error);
      }
    }
  });
}

module.exports = {
  addInterceptor: addInterceptor,
  remove: remove,
  removeAll: removeAll,
  removeInterceptor: removeInterceptor,
  isOn: isOn,
  activate: activate,
  isActive: isActive,
  isDone: isDone,
  pendingMocks: pendingMocks,
  activeMocks: activeMocks,
  enableNetConnect: enableNetConnect,
  disableNetConnect: disableNetConnect,
  restoreOverriddenClientRequest: restoreOverriddenClientRequest,
  abortPendingRequests: common.removeAllTimers
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImludGVyY2VwdC5qcyJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiSW50ZXJjZXB0ZWRSZXF1ZXN0Um91dGVyIiwiY29tbW9uIiwiaW5oZXJpdHMiLCJodHRwIiwiZGVidWciLCJnbG9iYWxFbWl0dGVyIiwiTmV0Q29ubmVjdE5vdEFsbG93ZWRFcnJvciIsImhvc3QiLCJwYXRoIiwiRXJyb3IiLCJjYWxsIiwibmFtZSIsImNvZGUiLCJtZXNzYWdlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJjb25zdHJ1Y3RvciIsImFsbEludGVyY2VwdG9ycyIsImFsbG93TmV0Q29ubmVjdCIsImVuYWJsZU5ldENvbm5lY3QiLCJtYXRjaGVyIiwiUmVnRXhwIiwidGVzdCIsImlzRW5hYmxlZEZvck5ldENvbm5lY3QiLCJvcHRpb25zIiwibm9ybWFsaXplUmVxdWVzdE9wdGlvbnMiLCJlbmFibGVkIiwiZGlzYWJsZU5ldENvbm5lY3QiLCJ1bmRlZmluZWQiLCJpc09uIiwiaXNPZmYiLCJwcm9jZXNzIiwiZW52IiwiTk9DS19PRkYiLCJhZGRJbnRlcmNlcHRvciIsImtleSIsImludGVyY2VwdG9yIiwic2NvcGUiLCJzY29wZU9wdGlvbnMiLCJpbnRlcmNlcHRvcnMiLCJfX25vY2tfc2NvcGUiLCJfX25vY2tfc2NvcGVLZXkiLCJfX25vY2tfc2NvcGVPcHRpb25zIiwiX19ub2NrX3Njb3BlSG9zdCIsImludGVyY2VwdGlvbkNvdW50ZXIiLCJhbGxvd1VubW9ja2VkIiwicHVzaCIsInJlbW92ZSIsInNob3VsZFBlcnNpc3QiLCJjb3VudGVyIiwiYmFzZVBhdGgiLCJzb21lIiwidGhpc0ludGVyY2VwdG9yIiwiaSIsInNwbGljZSIsInJlbW92ZUFsbCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5ZWRJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvcnNGb3IiLCJwcm90byIsInZhbHVlcyIsImZpbHRlcmluZ1Njb3BlIiwibG9nZ2VyIiwiaWMiLCJfX25vY2tfZmlsdGVyZWRTY29wZSIsIm1hdGNoU3RyaW5nT3JSZWdleHAiLCJsZW5ndGgiLCJtYXRjaE9yaWdpbiIsInJlbW92ZUludGVyY2VwdG9yIiwiSW50ZXJjZXB0b3IiLCJiYXNlVXJsIiwibWV0aG9kIiwiX2tleSIsInRvVXBwZXJDYXNlIiwib3JpZ2luYWxDbGllbnRSZXF1ZXN0IiwiRXJyb3JpbmdDbGllbnRSZXF1ZXN0IiwiZXJyb3IiLCJPdXRnb2luZ01lc3NhZ2UiLCJuZXh0VGljayIsImVtaXQiLCJiaW5kIiwiQ2xpZW50UmVxdWVzdCIsIm92ZXJyaWRlQ2xpZW50UmVxdWVzdCIsIk92ZXJyaWRkZW5DbGllbnRSZXF1ZXN0IiwiYXJncyIsIm5vcm1hbGl6ZUNsaWVudFJlcXVlc3RBcmdzIiwiY2FsbGJhY2siLCJvdmVycmlkZXIiLCJyZXEiLCJvbmNlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJzZXRJbW1lZGlhdGUiLCJyZXN0b3JlT3ZlcnJpZGRlbkNsaWVudFJlcXVlc3QiLCJpc0FjdGl2ZSIsImludGVyY2VwdG9yU2NvcGVzIiwibmVzdGVkSW50ZXJjZXB0b3JzIiwibWFwIiwiY29uY2F0IiwiaXNEb25lIiwiZXZlcnkiLCJwZW5kaW5nTW9ja3MiLCJhY3RpdmVNb2NrcyIsImFjdGl2YXRlIiwib3ZlcnJpZGVSZXF1ZXN0cyIsIm92ZXJyaWRkZW5SZXF1ZXN0IiwibWF0Y2hlcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJhYm9ydFBlbmRpbmdSZXF1ZXN0cyIsInJlbW92ZUFsbFRpbWVycyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0FBTUEsZUFBcUNBLE9BQU8sZ0NBQTVDO0FBQUEsSUFBUUMsd0JBQVIsWUFBUUEsd0JBQVI7O0FBQ0EsSUFBTUMsTUFBTSxHQUFHRixPQUFPLFlBQXRCOztBQUNBLGdCQUFxQkEsT0FBTyxDQUFDLE1BQUQsQ0FBNUI7QUFBQSxJQUFRRyxRQUFSLGFBQVFBLFFBQVI7O0FBQ0EsSUFBTUMsSUFBSSxHQUFHSixPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxJQUFNSyxLQUFL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LCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBAbW9kdWxlIG5vY2svaW50ZXJjZXB0XG4gKi9cblxuY29uc3QgeyBJbnRlcmNlcHRlZFJlcXVlc3RSb3V0ZXIgfSA9IHJlcXVpcmUoJy4vaW50ZXJjZXB0ZWRfcmVxdWVzdF9yb3V0ZXInKVxuY29uc3QgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKVxuY29uc3QgeyBpbmhlcml0cyB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpXG5jb25zdCBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ25vY2suaW50ZXJjZXB0JylcbmNvbnN0IGdsb2JhbEVtaXR0ZXIgPSByZXF1aXJlKCcuL2dsb2JhbF9lbWl0dGVyJylcblxuLyoqXG4gKiBAbmFtZSBOZXRDb25uZWN0Tm90QWxsb3dlZEVycm9yXG4gKiBAcHJpdmF0ZVxuICogQGRlc2MgRXJyb3IgdHJ5aW5nIHRvIG1ha2UgYSBjb25uZWN0aW9uIHdoZW4gZGlzYWJsZWQgZXh0ZXJuYWwgYWNjZXNzLlxuICogQGNsYXNzXG4gKiBAZXhhbXBsZVxuICogbm9jay5kaXNhYmxlTmV0Q29ubmVjdCgpO1xuICogaHR0cC5nZXQoJ2h0dHA6Ly96b21iby5jb20nKTtcbiAqIC8vIHRocm93IE5ldENvbm5lY3ROb3RBbGxvd2VkRXJyb3JcbiAqL1xuZnVuY3Rpb24gTmV0Q29ubmVjdE5vdEFsbG93ZWRFcnJvcihob3N0LCBwYXRoKSB7XG4gIEVycm9yLmNhbGwodGhpcylcblxuICB0aGlzLm5hbWUgPSAnTmV0Q29ubmVjdE5vdEFsbG93ZWRFcnJvcidcbiAgdGhpcy5jb2RlID0gJ0VORVRVTlJFQUNIJ1xuICB0aGlzLm1lc3NhZ2UgPSBgTm9jazogRGlzYWxsb3dlZCBuZXQgY29ubmVjdCBmb3IgXCIke2hvc3R9JHtwYXRofVwiYFxuXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpXG59XG5cbmluaGVyaXRzKE5ldENvbm5lY3ROb3RBbGxvd2VkRXJyb3IsIEVycm9yKVxuXG5sZXQgYWxsSW50ZXJjZXB0b3JzID0ge31cbmxldCBhbGxvd05ldENvbm5lY3RcblxuLyoqXG4gKiBFbmFibGVkIHJlYWwgcmVxdWVzdC5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbWF0Y2hlcj1SZWdFeHAubmV3KCcuKicpIEV4cHJlc3Npb24gdG8gbWF0Y2hcbiAqIEBleGFtcGxlXG4gKiAvLyBFbmFibGVzIGFsbCByZWFsIHJlcXVlc3RzXG4gKiBub2NrLmVuYWJsZU5ldENvbm5lY3QoKTtcbiAqIEBleGFtcGxlXG4gKiAvLyBFbmFibGVzIHJlYWwgcmVxdWVzdHMgZm9yIHVybCB0aGF0IG1hdGNoZXMgZ29vZ2xlXG4gKiBub2NrLmVuYWJsZU5ldENvbm5lY3QoJ2dvb2dsZScpO1xuICogQGV4YW1wbGVcbiAqIC8vIEVuYWJsZXMgcmVhbCByZXF1ZXN0cyBmb3IgdXJsIHRoYXQgbWF0Y2hlcyBnb29nbGUgYW5kIGFtYXpvblxuICogbm9jay5lbmFibGVOZXRDb25uZWN0KC8oZ29vZ2xlfGFtYXpvbikvKTtcbiAqIEBleGFtcGxlXG4gKiAvLyBFbmFibGVzIHJlYWwgcmVxdWVzdHMgZm9yIHVybCB0aGF0IGluY2x1ZGVzIGdvb2dsZVxuICogbm9jay5lbmFibGVOZXRDb25uZWN0KGhvc3QgPT4gaG9zdC5pbmNsdWRlcygnZ29vZ2xlJykpO1xuICovXG5mdW5jdGlvbiBlbmFibGVOZXRDb25uZWN0KG1hdGNoZXIpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJykge1xuICAgIGFsbG93TmV0Q29ubmVjdCA9IG5ldyBSZWdFeHAobWF0Y2hlcilcbiAgfSBlbHNlIGlmIChtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgYWxsb3dOZXRDb25uZWN0ID0gbWF0Y2hlclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYWxsb3dOZXRDb25uZWN0ID0geyB0ZXN0OiBtYXRjaGVyIH1cbiAgfSBlbHNlIHtcbiAgICBhbGxvd05ldENvbm5lY3QgPSAvLiovXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkRm9yTmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIGNvbW1vbi5ub3JtYWxpemVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKVxuXG4gIGNvbnN0IGVuYWJsZWQgPSBhbGxvd05ldENvbm5lY3QgJiYgYWxsb3dOZXRDb25uZWN0LnRlc3Qob3B0aW9ucy5ob3N0KVxuICBkZWJ1ZygnTmV0IGNvbm5lY3QnLCBlbmFibGVkID8gJycgOiAnbm90JywgJ2VuYWJsZWQgZm9yJywgb3B0aW9ucy5ob3N0KVxuICByZXR1cm4gZW5hYmxlZFxufVxuXG4vKipcbiAqIERpc2FibGUgYWxsIHJlYWwgcmVxdWVzdHMuXG4gKiBAcHVibGljXG4gKiBAZXhhbXBsZVxuICogbm9jay5kaXNhYmxlTmV0Q29ubmVjdCgpO1xuICovXG5mdW5jdGlvbiBkaXNhYmxlTmV0Q29ubmVjdCgpIHtcbiAgYWxsb3dOZXRDb25uZWN0ID0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzT24oKSB7XG4gIHJldHVybiAhaXNPZmYoKVxufVxuXG5mdW5jdGlvbiBpc09mZigpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PQ0tfT0ZGID09PSAndHJ1ZSdcbn1cblxuZnVuY3Rpb24gYWRkSW50ZXJjZXB0b3Ioa2V5LCBpbnRlcmNlcHRvciwgc2NvcGUsIHNjb3BlT3B0aW9ucywgaG9zdCkge1xuICBpZiAoIShrZXkgaW4gYWxsSW50ZXJjZXB0b3JzKSkge1xuICAgIGFsbEludGVyY2VwdG9yc1trZXldID0geyBrZXksIGludGVyY2VwdG9yczogW10gfVxuICB9XG4gIGludGVyY2VwdG9yLl9fbm9ja19zY29wZSA9IHNjb3BlXG5cbiAgLy8gIFdlIG5lZWQgc2NvcGUncyBrZXkgYW5kIHNjb3BlIG9wdGlvbnMgZm9yIHNjb3BlIGZpbHRlcmluZyBmdW5jdGlvbiAoaWYgZGVmaW5lZClcbiAgaW50ZXJjZXB0b3IuX19ub2NrX3Njb3BlS2V5ID0ga2V5XG4gIGludGVyY2VwdG9yLl9fbm9ja19zY29wZU9wdGlvbnMgPSBzY29wZU9wdGlvbnNcbiAgLy8gIFdlIG5lZWQgc2NvcGUncyBob3N0IGZvciBzZXR0aW5nIGNvcnJlY3QgcmVxdWVzdCBoZWFkZXJzIGZvciBmaWx0ZXJlZCBzY29wZXMuXG4gIGludGVyY2VwdG9yLl9fbm9ja19zY29wZUhvc3QgPSBob3N0XG4gIGludGVyY2VwdG9yLmludGVyY2VwdGlvbkNvdW50ZXIgPSAwXG5cbiAgaWYgKHNjb3BlT3B0aW9ucy5hbGxvd1VubW9ja2VkKSBhbGxJbnRlcmNlcHRvcnNba2V5XS5hbGxvd1VubW9ja2VkID0gdHJ1ZVxuXG4gIGFsbEludGVyY2VwdG9yc1trZXldLmludGVyY2VwdG9ycy5wdXNoKGludGVyY2VwdG9yKVxufVxuXG5mdW5jdGlvbiByZW1vdmUoaW50ZXJjZXB0b3IpIHtcbiAgaWYgKGludGVyY2VwdG9yLl9fbm9ja19zY29wZS5zaG91bGRQZXJzaXN0KCkgfHwgLS1pbnRlcmNlcHRvci5jb3VudGVyID4gMCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBiYXNlUGF0aCB9ID0gaW50ZXJjZXB0b3JcbiAgY29uc3QgaW50ZXJjZXB0b3JzID1cbiAgICAoYWxsSW50ZXJjZXB0b3JzW2Jhc2VQYXRoXSAmJiBhbGxJbnRlcmNlcHRvcnNbYmFzZVBhdGhdLmludGVyY2VwdG9ycykgfHwgW11cblxuICAvLyBUT0RPOiBUaGVyZSBpcyBhIGNsZWFyZXIgd2F5IHRvIHdyaXRlIHRoYXQgd2Ugd2FudCB0byBkZWxldGUgdGhlIGZpcnN0XG4gIC8vIG1hdGNoaW5nIGluc3RhbmNlLiBJJ20gYWxzbyBub3Qgc3VyZSB3aHkgd2UgY291bGRuJ3QgZGVsZXRlIF9hbGxfXG4gIC8vIG1hdGNoaW5nIGluc3RhbmNlcy5cbiAgaW50ZXJjZXB0b3JzLnNvbWUoZnVuY3Rpb24gKHRoaXNJbnRlcmNlcHRvciwgaSkge1xuICAgIHJldHVybiB0aGlzSW50ZXJjZXB0b3IgPT09IGludGVyY2VwdG9yID8gaW50ZXJjZXB0b3JzLnNwbGljZShpLCAxKSA6IGZhbHNlXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgT2JqZWN0LmtleXMoYWxsSW50ZXJjZXB0b3JzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBhbGxJbnRlcmNlcHRvcnNba2V5XS5pbnRlcmNlcHRvcnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yLnNjb3BlLmtleWVkSW50ZXJjZXB0b3JzID0ge31cbiAgICB9KVxuICB9KVxuICBhbGxJbnRlcmNlcHRvcnMgPSB7fVxufVxuXG4vKipcbiAqIFJldHVybiBhbGwgdGhlIEludGVyY2VwdG9ycyB3aG9zZSBTY29wZXMgbWF0Y2ggYWdhaW5zdCB0aGUgYmFzZSBwYXRoIG9mIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIHtJbnRlcmNlcHRvcltdfVxuICovXG5mdW5jdGlvbiBpbnRlcmNlcHRvcnNGb3Iob3B0aW9ucykge1xuICBjb21tb24ubm9ybWFsaXplUmVxdWVzdE9wdGlvbnMob3B0aW9ucylcblxuICBkZWJ1ZygnaW50ZXJjZXB0b3JzIGZvciAlaicsIG9wdGlvbnMuaG9zdClcblxuICBjb25zdCBiYXNlUGF0aCA9IGAke29wdGlvbnMucHJvdG99Oi8vJHtvcHRpb25zLmhvc3R9YFxuXG4gIGRlYnVnKCdmaWx0ZXJpbmcgaW50ZXJjZXB0b3JzIGZvciBiYXNlcGF0aCcsIGJhc2VQYXRoKVxuXG4gIC8vIEZpcnN0IHRyeSB0byB1c2UgZmlsdGVyaW5nU2NvcGUgaWYgYW55IG9mIHRoZSBpbnRlcmNlcHRvcnMgaGFzIGl0IGRlZmluZWQuXG4gIGZvciAoY29uc3QgeyBrZXksIGludGVyY2VwdG9ycywgYWxsb3dVbm1vY2tlZCB9IG9mIE9iamVjdC52YWx1ZXMoXG4gICAgYWxsSW50ZXJjZXB0b3JzXG4gICkpIHtcbiAgICBmb3IgKGNvbnN0IGludGVyY2VwdG9yIG9mIGludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgeyBmaWx0ZXJpbmdTY29wZSB9ID0gaW50ZXJjZXB0b3IuX19ub2NrX3Njb3BlT3B0aW9uc1xuXG4gICAgICAvLyBJZiBzY29wZSBmaWx0ZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZCBhbmQgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSB0aGVuXG4gICAgICAvLyB3ZSBoYXZlIHRvIHRyZWF0IHRoaXMgYXMgYSBtYXRjaC5cbiAgICAgIGlmIChmaWx0ZXJpbmdTY29wZSAmJiBmaWx0ZXJpbmdTY29wZShiYXNlUGF0aCkpIHtcbiAgICAgICAgaW50ZXJjZXB0b3Iuc2NvcGUubG9nZ2VyKCdmb3VuZCBtYXRjaGluZyBzY29wZSBpbnRlcmNlcHRvcicpXG5cbiAgICAgICAgLy8gS2VlcCB0aGUgZmlsdGVyZWQgc2NvcGUgKGl0cyBrZXkpIHRvIHNpZ25hbCB0aGUgcmVzdCBvZiB0aGUgbW9kdWxlXG4gICAgICAgIC8vIHRoYXQgdGhpcyB3YXNuJ3QgYW4gZXhhY3QgYnV0IGZpbHRlcmVkIG1hdGNoLlxuICAgICAgICBpbnRlcmNlcHRvcnMuZm9yRWFjaChpYyA9PiB7XG4gICAgICAgICAgaWMuX19ub2NrX2ZpbHRlcmVkU2NvcGUgPSBpYy5fX25vY2tfc2NvcGVLZXlcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdG9yc1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21tb24ubWF0Y2hTdHJpbmdPclJlZ2V4cChiYXNlUGF0aCwga2V5KSkge1xuICAgICAgaWYgKGFsbG93VW5tb2NrZWQgJiYgaW50ZXJjZXB0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWJ1ZygnbWF0Y2hlZCBiYXNlIHBhdGggd2l0aCBhbGxvd1VubW9ja2VkIChubyBtYXRjaGluZyBpbnRlcmNlcHRvcnMpJylcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBvcHRpb25zOiB7IGFsbG93VW5tb2NrZWQ6IHRydWUgfSxcbiAgICAgICAgICAgIG1hdGNoT3JpZ2luKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgYG1hdGNoZWQgYmFzZSBwYXRoICgke2ludGVyY2VwdG9ycy5sZW5ndGh9IGludGVyY2VwdG9yJHtcbiAgICAgICAgICAgIGludGVyY2VwdG9ycy5sZW5ndGggPiAxID8gJ3MnIDogJydcbiAgICAgICAgICB9KWBcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gaW50ZXJjZXB0b3JzXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiByZW1vdmVJbnRlcmNlcHRvcihvcHRpb25zKSB7XG4gIC8vIExhemlseSBpbXBvcnQgdG8gYXZvaWQgY2lyY3VsYXIgaW1wb3J0cy5cbiAgY29uc3QgSW50ZXJjZXB0b3IgPSByZXF1aXJlKCcuL2ludGVyY2VwdG9yJylcblxuICBsZXQgYmFzZVVybCwga2V5LCBtZXRob2QsIHByb3RvXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgSW50ZXJjZXB0b3IpIHtcbiAgICBiYXNlVXJsID0gb3B0aW9ucy5iYXNlUGF0aFxuICAgIGtleSA9IG9wdGlvbnMuX2tleVxuICB9IGVsc2Uge1xuICAgIHByb3RvID0gb3B0aW9ucy5wcm90byA/IG9wdGlvbnMucHJvdG8gOiAnaHR0cCdcblxuICAgIGNvbW1vbi5ub3JtYWxpemVSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKVxuICAgIGJhc2VVcmwgPSBgJHtwcm90b306Ly8ke29wdGlvbnMuaG9zdH1gXG4gICAgbWV0aG9kID0gKG9wdGlvbnMubWV0aG9kICYmIG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkpIHx8ICdHRVQnXG4gICAga2V5ID0gYCR7bWV0aG9kfSAke2Jhc2VVcmx9JHtvcHRpb25zLnBhdGggfHwgJy8nfWBcbiAgfVxuXG4gIGlmIChcbiAgICBhbGxJbnRlcmNlcHRvcnNbYmFzZVVybF0gJiZcbiAgICBhbGxJbnRlcmNlcHRvcnNbYmFzZVVybF0uaW50ZXJjZXB0b3JzLmxlbmd0aCA+IDBcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxJbnRlcmNlcHRvcnNbYmFzZVVybF0uaW50ZXJjZXB0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnRlcmNlcHRvciA9IGFsbEludGVyY2VwdG9yc1tiYXNlVXJsXS5pbnRlcmNlcHRvcnNbaV1cbiAgICAgIGlmIChpbnRlcmNlcHRvci5fa2V5ID09PSBrZXkpIHtcbiAgICAgICAgYWxsSW50ZXJjZXB0b3JzW2Jhc2VVcmxdLmludGVyY2VwdG9ycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgaW50ZXJjZXB0b3Iuc2NvcGUucmVtb3ZlKGtleSwgaW50ZXJjZXB0b3IpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuLy8gIFZhcmlhYmxlIHdoZXJlIHdlIGtlZXAgdGhlIENsaWVudFJlcXVlc3Qgd2UgaGF2ZSBvdmVycmlkZGVuXG4vLyAgKHdoaWNoIG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBub2RlJ3Mgb3JpZ2luYWwgaHR0cC5DbGllbnRSZXF1ZXN0KVxubGV0IG9yaWdpbmFsQ2xpZW50UmVxdWVzdFxuXG5mdW5jdGlvbiBFcnJvcmluZ0NsaWVudFJlcXVlc3QoZXJyb3IpIHtcbiAgaHR0cC5PdXRnb2luZ01lc3NhZ2UuY2FsbCh0aGlzKVxuICBwcm9jZXNzLm5leHRUaWNrKFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcilcbiAgICB9LmJpbmQodGhpcylcbiAgKVxufVxuXG5pbmhlcml0cyhFcnJvcmluZ0NsaWVudFJlcXVlc3QsIGh0dHAuQ2xpZW50UmVxdWVzdClcblxuZnVuY3Rpb24gb3ZlcnJpZGVDbGllbnRSZXF1ZXN0KCkge1xuICAvLyBIZXJlJ3Mgc29tZSBiYWNrZ3JvdW5kIGRpc2N1c3Npb24gYWJvdXQgb3ZlcnJpZGluZyBDbGllbnRSZXF1ZXN0OlxuICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2Rlaml0c3UvbW9jay1yZXF1ZXN0L2lzc3Vlcy80XG4gIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL25vY2svbm9jay9pc3N1ZXMvMjZcbiAgLy8gSXQgd291bGQgYmUgZ29vZCB0byBhZGQgYSBjb21tZW50IHRoYXQgZXhwbGFpbnMgdGhpcyBtb3JlIGNsZWFybHkuXG4gIGRlYnVnKCdPdmVycmlkaW5nIENsaWVudFJlcXVlc3QnKVxuXG4gIC8vIC0tLS0tIEV4dGVuZGluZyBodHRwLkNsaWVudFJlcXVlc3RcblxuICAvLyAgRGVmaW5lIHRoZSBvdmVycmlkaW5nIGNsaWVudCByZXF1ZXN0IHRoYXQgbm9jayB1c2VzIGludGVybmFsbHkuXG4gIGZ1bmN0aW9uIE92ZXJyaWRkZW5DbGllbnRSZXF1ZXN0KC4uLmFyZ3MpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIGNhbGxiYWNrIH0gPSBjb21tb24ubm9ybWFsaXplQ2xpZW50UmVxdWVzdEFyZ3MoLi4uYXJncylcblxuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEFzIHdlaXJkIGFzIGl0IGlzLCBpdCdzIHBvc3NpYmxlIHRvIGNhbGwgYGh0dHAucmVxdWVzdGAgd2l0aG91dFxuICAgICAgLy8gb3B0aW9ucywgYW5kIGl0IG1ha2VzIGEgcmVxdWVzdCB0byBsb2NhbGhvc3Qgb3Igc29tZXN1Y2guIFdlIHNob3VsZFxuICAgICAgLy8gc3VwcG9ydCBpdCB0b28sIGZvciBwYXJpdHkuIEhvd2V2ZXIgaXQgZG9lc24ndCB3b3JrIHRvZGF5LCBhbmQgZml4aW5nXG4gICAgICAvLyBpdCBzZWVtcyBsb3cgcHJpb3JpdHkuIEdpdmluZyBhbiBleHBsaWNpdCBlcnJvciBpcyBuaWNlciB0aGFuXG4gICAgICAvLyBjcmFzaGluZyB3aXRoIGEgd2VpcmQgc3RhY2sgdHJhY2UuIGBodHRwW3NdLnJlcXVlc3QoKWAsIG5vY2sncyBvdGhlclxuICAgICAgLy8gY2xpZW50LWZhY2luZyBlbnRyeSBwb2ludCwgbWFrZXMgYSBzaW1pbGFyIGNoZWNrLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vY2svbm9jay9wdWxsLzEzODZcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2NrL25vY2svcHVsbC8xNDQwXG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgJ0NyZWF0aW5nIGEgQ2xpZW50UmVxdWVzdCB3aXRoIGVtcHR5IGBvcHRpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIE5vY2snXG4gICAgICApXG4gICAgfVxuXG4gICAgaHR0cC5PdXRnb2luZ01lc3NhZ2UuY2FsbCh0aGlzKVxuXG4gICAgLy8gIEZpbHRlciB0aGUgaW50ZXJjZXB0b3JzIHBlciByZXF1ZXN0IG9wdGlvbnMuXG4gICAgY29uc3QgaW50ZXJjZXB0b3JzID0gaW50ZXJjZXB0b3JzRm9yKG9wdGlvbnMpXG5cbiAgICBpZiAoaXNPbigpICYmIGludGVyY2VwdG9ycykge1xuICAgICAgZGVidWcoJ3VzaW5nJywgaW50ZXJjZXB0b3JzLmxlbmd0aCwgJ2ludGVyY2VwdG9ycycpXG5cbiAgICAgIC8vICBVc2UgZmlsdGVyZWQgaW50ZXJjZXB0b3JzIHRvIGludGVyY2VwdCByZXF1ZXN0cy5cbiAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkbid0IGJlIGEgY2xhc3MgYW55bW9yZVxuICAgICAgLy8gdGhlIG92ZXJyaWRlciBleHBsaWNpdGx5IG92ZXJyaWRlcyBtZXRob2RzIGFuZCBhdHRycyBvbiB0aGUgcmVxdWVzdCBzbyB0aGUgYGFzc2lnbmAgYmVsb3cgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICBjb25zdCBvdmVycmlkZXIgPSBuZXcgSW50ZXJjZXB0ZWRSZXF1ZXN0Um91dGVyKHtcbiAgICAgICAgcmVxOiB0aGlzLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbnRlcmNlcHRvcnMsXG4gICAgICB9KVxuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvdmVycmlkZXIpXG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uY2UoJ3Jlc3BvbnNlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gb3JpZ2luYWwgQ2xpZW50UmVxdWVzdCcpXG5cbiAgICAgIC8vICBGYWxsYmFjayB0byBvcmlnaW5hbCBDbGllbnRSZXF1ZXN0IGlmIG5vY2sgaXMgb2ZmIG9yIHRoZSBuZXQgY29ubmVjdGlvbiBpcyBlbmFibGVkLlxuICAgICAgaWYgKGlzT2ZmKCkgfHwgaXNFbmFibGVkRm9yTmV0Q29ubmVjdChvcHRpb25zKSkge1xuICAgICAgICBvcmlnaW5hbENsaWVudFJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbW9uLnNldEltbWVkaWF0ZShcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBOZXRDb25uZWN0Tm90QWxsb3dlZEVycm9yKFxuICAgICAgICAgICAgICBvcHRpb25zLmhvc3QsXG4gICAgICAgICAgICAgIG9wdGlvbnMucGF0aFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKVxuICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluaGVyaXRzKE92ZXJyaWRkZW5DbGllbnRSZXF1ZXN0LCBodHRwLkNsaWVudFJlcXVlc3QpXG5cbiAgLy8gIE92ZXJyaWRlIHRoZSBodHRwIG1vZHVsZSdzIHJlcXVlc3QgYnV0IGtlZXAgdGhlIG9yaWdpbmFsIHNvIHRoYXQgd2UgY2FuIHVzZSBpdCBhbmQgbGF0ZXIgcmVzdG9yZSBpdC5cbiAgLy8gIE5PVEU6IFdlIG9ubHkgb3ZlcnJpZGUgaHR0cC5DbGllbnRSZXF1ZXN0IGFzIGh0dHBzIG1vZHVsZSBhbHNvIHVzZXMgaXQuXG4gIG9yaWdpbmFsQ2xpZW50UmVxdWVzdCA9IGh0dHAuQ2xpZW50UmVxdWVzdFxuICBodHRwLkNsaWVudFJlcXVlc3QgPSBPdmVycmlkZGVuQ2xpZW50UmVxdWVzdFxuXG4gIGRlYnVnKCdDbGllbnRSZXF1ZXN0IG92ZXJyaWRkZW4nKVxufVxuXG5mdW5jdGlvbiByZXN0b3JlT3ZlcnJpZGRlbkNsaWVudFJlcXVlc3QoKSB7XG4gIGRlYnVnKCdyZXN0b3Jpbmcgb3ZlcnJpZGRlbiBDbGllbnRSZXF1ZXN0JylcblxuICAvLyAgUmVzdG9yZSB0aGUgQ2xpZW50UmVxdWVzdCB3ZSBoYXZlIG92ZXJyaWRkZW4uXG4gIGlmICghb3JpZ2luYWxDbGllbnRSZXF1ZXN0KSB7XG4gICAgZGVidWcoJy0gQ2xpZW50UmVxdWVzdCB3YXMgbm90IG92ZXJyaWRkZW4nKVxuICB9IGVsc2Uge1xuICAgIGh0dHAuQ2xpZW50UmVxdWVzdCA9IG9yaWdpbmFsQ2xpZW50UmVxdWVzdFxuICAgIG9yaWdpbmFsQ2xpZW50UmVxdWVzdCA9IHVuZGVmaW5lZFxuXG4gICAgZGVidWcoJy0gQ2xpZW50UmVxdWVzdCByZXN0b3JlZCcpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gIC8vICBJZiBDbGllbnRSZXF1ZXN0IGhhcyBiZWVuIG92ZXJ3cml0dGVuIGJ5IE5vY2sgdGhlbiBvcmlnaW5hbENsaWVudFJlcXVlc3QgaXMgbm90IHVuZGVmaW5lZC5cbiAgLy8gIFRoaXMgbWVhbnMgdGhhdCBOb2NrIGhhcyBiZWVuIGFjdGl2YXRlZC5cbiAgcmV0dXJuIG9yaWdpbmFsQ2xpZW50UmVxdWVzdCAhPT0gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGludGVyY2VwdG9yU2NvcGVzKCkge1xuICBjb25zdCBuZXN0ZWRJbnRlcmNlcHRvcnMgPSBPYmplY3QudmFsdWVzKGFsbEludGVyY2VwdG9ycykubWFwKFxuICAgIGkgPT4gaS5pbnRlcmNlcHRvcnNcbiAgKVxuICByZXR1cm4gW10uY29uY2F0KC4uLm5lc3RlZEludGVyY2VwdG9ycykubWFwKGkgPT4gaS5zY29wZSlcbn1cblxuZnVuY3Rpb24gaXNEb25lKCkge1xuICByZXR1cm4gaW50ZXJjZXB0b3JTY29wZXMoKS5ldmVyeShzY29wZSA9PiBzY29wZS5pc0RvbmUoKSlcbn1cblxuZnVuY3Rpb24gcGVuZGluZ01vY2tzKCkge1xuICByZXR1cm4gW10uY29uY2F0KC4uLmludGVyY2VwdG9yU2NvcGVzKCkubWFwKHNjb3BlID0+IHNjb3BlLnBlbmRpbmdNb2NrcygpKSlcbn1cblxuZnVuY3Rpb24gYWN0aXZlTW9ja3MoKSB7XG4gIHJldHVybiBbXS5jb25jYXQoLi4uaW50ZXJjZXB0b3JTY29wZXMoKS5tYXAoc2NvcGUgPT4gc2NvcGUuYWN0aXZlTW9ja3MoKSkpXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlKCkge1xuICBpZiAob3JpZ2luYWxDbGllbnRSZXF1ZXN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb2NrIGFscmVhZHkgYWN0aXZlJylcbiAgfVxuXG4gIG92ZXJyaWRlQ2xpZW50UmVxdWVzdCgpXG5cbiAgLy8gLS0tLS0gT3ZlcnJpZGluZyBodHRwLnJlcXVlc3QgYW5kIGh0dHBzLnJlcXVlc3Q6XG5cbiAgY29tbW9uLm92ZXJyaWRlUmVxdWVzdHMoZnVuY3Rpb24gKHByb3RvLCBvdmVycmlkZGVuUmVxdWVzdCwgYXJncykge1xuICAgIC8vICBOT1RFOiBvdmVycmlkZGVuUmVxdWVzdCBpcyBhbHJlYWR5IGJvdW5kIHRvIGl0cyBtb2R1bGUuXG5cbiAgICBjb25zdCB7IG9wdGlvbnMsIGNhbGxiYWNrIH0gPSBjb21tb24ubm9ybWFsaXplQ2xpZW50UmVxdWVzdEFyZ3MoLi4uYXJncylcblxuICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEFzIHdlaXJkIGFzIGl0IGlzLCBpdCdzIHBvc3NpYmxlIHRvIGNhbGwgYGh0dHAucmVxdWVzdGAgd2l0aG91dFxuICAgICAgLy8gb3B0aW9ucywgYW5kIGl0IG1ha2VzIGEgcmVxdWVzdCB0byBsb2NhbGhvc3Qgb3Igc29tZXN1Y2guIFdlIHNob3VsZFxuICAgICAgLy8gc3VwcG9ydCBpdCB0b28sIGZvciBwYXJpdHkuIEhvd2V2ZXIgaXQgZG9lc24ndCB3b3JrIHRvZGF5LCBhbmQgZml4aW5nXG4gICAgICAvLyBpdCBzZWVtcyBsb3cgcHJpb3JpdHkuIEdpdmluZyBhbiBleHBsaWNpdCBlcnJvciBpcyBuaWNlciB0aGFuXG4gICAgICAvLyBjcmFzaGluZyB3aXRoIGEgd2VpcmQgc3RhY2sgdHJhY2UuIGBuZXcgQ2xpZW50UmVxdWVzdCgpYCwgbm9jaydzXG4gICAgICAvLyBvdGhlciBjbGllbnQtZmFjaW5nIGVudHJ5IHBvaW50LCBtYWtlcyBhIHNpbWlsYXIgY2hlY2suXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9jay9ub2NrL3B1bGwvMTM4NlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vY2svbm9jay9wdWxsLzE0NDBcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnTWFraW5nIGEgcmVxdWVzdCB3aXRoIGVtcHR5IGBvcHRpb25zYCBpcyBub3Qgc3VwcG9ydGVkIGluIE5vY2snXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVGhlIG9wdGlvbiBwZXIgdGhlIGRvY3MgaXMgYHByb3RvY29sYC4gSXRzIHVuY2xlYXIgaWYgdGhpcyBsaW5lIGlzIG1lYW50IHRvIG92ZXJyaWRlIHRoYXQgYW5kIGlzIG1pc3NwZWxsZWQgb3IgaWZcbiAgICAvLyB0aGUgaW50ZW5kIGlzIHRvIGV4cGxpY2l0bHkga2VlcCB0cmFjayBvZiB3aGljaCBtb2R1bGUgd2FzIGNhbGxlZCB1c2luZyBhIHNlcGFyYXRlIG5hbWUuXG4gICAgLy8gRWl0aGVyIHdheSwgYHByb3RvYCBpcyB1c2VkIGFzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZnJvbSBoZXJlIG9uIG91dC5cbiAgICBvcHRpb25zLnByb3RvID0gcHJvdG9cblxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGludGVyY2VwdG9yc0ZvcihvcHRpb25zKVxuXG4gICAgaWYgKGlzT24oKSAmJiBpbnRlcmNlcHRvcnMpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBpbnRlcmNlcHRvcnMuc29tZShpbnRlcmNlcHRvciA9PlxuICAgICAgICBpbnRlcmNlcHRvci5tYXRjaE9yaWdpbihvcHRpb25zKVxuICAgICAgKVxuICAgICAgY29uc3QgYWxsb3dVbm1vY2tlZCA9IGludGVyY2VwdG9ycy5zb21lKFxuICAgICAgICBpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvci5vcHRpb25zLmFsbG93VW5tb2NrZWRcbiAgICAgIClcblxuICAgICAgaWYgKCFtYXRjaGVzICYmIGFsbG93VW5tb2NrZWQpIHtcbiAgICAgICAgbGV0IHJlcVxuICAgICAgICBpZiAocHJvdG8gPT09ICdodHRwcycpIHtcbiAgICAgICAgICBjb25zdCB7IENsaWVudFJlcXVlc3QgfSA9IGh0dHBcbiAgICAgICAgICBodHRwLkNsaWVudFJlcXVlc3QgPSBvcmlnaW5hbENsaWVudFJlcXVlc3RcbiAgICAgICAgICByZXEgPSBvdmVycmlkZGVuUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaylcbiAgICAgICAgICBodHRwLkNsaWVudFJlcXVlc3QgPSBDbGllbnRSZXF1ZXN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxID0gb3ZlcnJpZGRlblJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsRW1pdHRlci5lbWl0KCdubyBtYXRjaCcsIHJlcSlcbiAgICAgICAgcmV0dXJuIHJlcVxuICAgICAgfVxuXG4gICAgICAvLyAgTk9URTogU2luY2Ugd2UgYWxyZWFkeSBvdmVycm9kZSB0aGUgaHR0cC5DbGllbnRSZXF1ZXN0IHdlIGFyZSBpbiBmYWN0IGNvbnN0cnVjdGluZ1xuICAgICAgLy8gICAgb3VyIG93biBPdmVycmlkZGVuQ2xpZW50UmVxdWVzdC5cbiAgICAgIHJldHVybiBuZXcgaHR0cC5DbGllbnRSZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWxFbWl0dGVyLmVtaXQoJ25vIG1hdGNoJywgb3B0aW9ucylcbiAgICAgIGlmIChpc09mZigpIHx8IGlzRW5hYmxlZEZvck5ldENvbm5lY3Qob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRkZW5SZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTmV0Q29ubmVjdE5vdEFsbG93ZWRFcnJvcihvcHRpb25zLmhvc3QsIG9wdGlvbnMucGF0aClcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcmluZ0NsaWVudFJlcXVlc3QoZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkSW50ZXJjZXB0b3IsXG4gIHJlbW92ZSxcbiAgcmVtb3ZlQWxsLFxuICByZW1vdmVJbnRlcmNlcHRvcixcbiAgaXNPbixcbiAgYWN0aXZhdGUsXG4gIGlzQWN0aXZlLFxuICBpc0RvbmUsXG4gIHBlbmRpbmdNb2NrcyxcbiAgYWN0aXZlTW9ja3MsXG4gIGVuYWJsZU5ldENvbm5lY3QsXG4gIGRpc2FibGVOZXRDb25uZWN0LFxuICByZXN0b3JlT3ZlcnJpZGRlbkNsaWVudFJlcXVlc3QsXG4gIGFib3J0UGVuZGluZ1JlcXVlc3RzOiBjb21tb24ucmVtb3ZlQWxsVGltZXJzLFxufVxuIl19