{"version":3,"sources":["intercepted_request_router.js"],"names":["debug","require","IncomingMessage","ClientRequest","originalHttpRequest","request","originalHttpsRequest","propagate","common","globalEmitter","Socket","playbackInterceptor","socketOnClose","req","res","socket","_hadError","err","Error","code","emit","InterceptedRequestRouter","options","interceptors","headers","headersFieldNamesToLowerCase","timeout","setTimeout","response","requestBodyBuffers","playbackStarted","readyToStartPlaybackOnSocketEvent","attachToReq","process","nextTick","connectSocket","Object","entries","name","val","setHeader","toLowerCase","auth","authorization","Buffer","from","toString","path","method","write","handleWrite","end","handleEnd","flushHeaders","handleFlushHeaders","expect","setImmediate","isRequestDestroyed","connection","on","connecting","authorized","maybeStartPlayback","buffer","encoding","callback","finished","destroyed","length","isBuffer","push","chunk","once","interceptor","HOST_HEADER","__nock_filteredScope","__nock_scopeHost","host","getHeader","hostHeader","port","split","startPlayback","getHeaders","protocol","proto","forEach","setHostHeaderUsingInterceptor","requestBodyBuffer","concat","requestBodyIsUtf8Representable","isUtf8Representable","requestBodyString","matchedInterceptor","find","i","match","scope","logger","markConsumed","allowUnmocked","some","matchHostName","newReq","reqStr","stringifyRequest","statusCode","status","destroy","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.request_overrider')\nconst {\n  IncomingMessage,\n  ClientRequest,\n  request: originalHttpRequest,\n} = require('http')\nconst { request: originalHttpsRequest } = require('https')\nconst propagate = require('propagate')\nconst common = require('./common')\nconst globalEmitter = require('./global_emitter')\nconst Socket = require('./socket')\nconst { playbackInterceptor } = require('./playback_interceptor')\n\nfunction socketOnClose(req) {\n  debug('socket close')\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true\n    const err = new Error('socket hang up')\n    err.code = 'ECONNRESET'\n    req.emit('error', err)\n  }\n  req.emit('close')\n}\n\n/**\n * Given a group of interceptors, appropriately route an outgoing request.\n * Identify which interceptor ought to respond, if any, then delegate to\n * `playbackInterceptor()` to consume the request itself.\n */\nclass InterceptedRequestRouter {\n  constructor({ req, options, interceptors }) {\n    this.req = req\n    this.options = {\n      // We may be changing the options object and we don't want those changes\n      // affecting the user so we use a clone of the object.\n      ...options,\n      // We use lower-case header field names throughout Nock.\n      headers: common.headersFieldNamesToLowerCase(options.headers || {}),\n    }\n    this.interceptors = interceptors\n\n    this.socket = new Socket(options)\n\n    // support setting `timeout` using request `options`\n    // https://nodejs.org/docs/latest-v12.x/api/http.html#http_http_request_url_options_callback\n    if (options.timeout) {\n      this.socket.setTimeout(options.timeout)\n    }\n\n    this.response = new IncomingMessage(this.socket)\n    this.requestBodyBuffers = []\n    this.playbackStarted = false\n\n    // For parity with Node, it's important the socket event is emitted before we begin playback.\n    // This flag is set when playback is triggered if we haven't yet gotten the\n    // socket event to indicate that playback should start as soon as it comes in.\n    this.readyToStartPlaybackOnSocketEvent = false\n\n    this.attachToReq()\n\n    // Emit a fake socket event on the next tick to mimic what would happen on a real request.\n    // Some clients listen for a 'socket' event to be emitted before calling end(),\n    // which causes Nock to hang.\n    process.nextTick(() => this.connectSocket())\n  }\n\n  attachToReq() {\n    const { req, options } = this\n\n    for (const [name, val] of Object.entries(options.headers)) {\n      req.setHeader(name.toLowerCase(), val)\n    }\n\n    if (options.auth && !options.headers.authorization) {\n      req.setHeader(\n        // We use lower-case header field names throughout Nock.\n        'authorization',\n        `Basic ${Buffer.from(options.auth).toString('base64')}`\n      )\n    }\n\n    req.path = options.path\n    req.method = options.method\n\n    req.write = (...args) => this.handleWrite(...args)\n    req.end = (...args) => this.handleEnd(...args)\n    req.flushHeaders = (...args) => this.handleFlushHeaders(...args)\n\n    // https://github.com/nock/nock/issues/256\n    if (options.headers.expect === '100-continue') {\n      common.setImmediate(() => {\n        debug('continue')\n        req.emit('continue')\n      })\n    }\n  }\n\n  connectSocket() {\n    const { req, socket } = this\n\n    if (common.isRequestDestroyed(req)) {\n      return\n    }\n\n    // ClientRequest.connection is an alias for ClientRequest.socket\n    // https://nodejs.org/api/http.html#http_request_socket\n    // https://github.com/nodejs/node/blob/b0f75818f39ed4e6bd80eb7c4010c1daf5823ef7/lib/_http_client.js#L640-L641\n    // The same Socket is shared between the request and response to mimic native behavior.\n    req.socket = req.connection = socket\n\n    propagate(['error', 'timeout'], socket, req)\n    socket.on('close', () => socketOnClose(req))\n\n    socket.connecting = false\n    req.emit('socket', socket)\n\n    // https://nodejs.org/api/net.html#net_event_connect\n    socket.emit('connect')\n\n    // https://nodejs.org/api/tls.html#tls_event_secureconnect\n    if (socket.authorized) {\n      socket.emit('secureConnect')\n    }\n\n    if (this.readyToStartPlaybackOnSocketEvent) {\n      this.maybeStartPlayback()\n    }\n  }\n\n  // from docs: When write function is called with empty string or buffer, it does nothing and waits for more input.\n  // However, actually implementation checks the state of finished and aborted before checking if the first arg is empty.\n  handleWrite(buffer, encoding, callback) {\n    debug('request write')\n    const { req } = this\n\n    if (req.finished) {\n      const err = new Error('write after end')\n      err.code = 'ERR_STREAM_WRITE_AFTER_END'\n      process.nextTick(() => req.emit('error', err))\n\n      // It seems odd to return `true` here, not sure why you'd want to have\n      // the stream potentially written to more, but it's what Node does.\n      // https://github.com/nodejs/node/blob/a9270dcbeba4316b1e179b77ecb6c46af5aa8c20/lib/_http_outgoing.js#L662-L665\n      return true\n    }\n\n    if (req.socket && req.socket.destroyed) {\n      return false\n    }\n\n    if (!buffer || buffer.length === 0) {\n      return true\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding)\n    }\n    this.requestBodyBuffers.push(buffer)\n\n    // can't use instanceof Function because some test runners\n    // run tests in vm.runInNewContext where Function is not same\n    // as that in the current context\n    // https://github.com/nock/nock/pull/1754#issuecomment-571531407\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    common.setImmediate(function () {\n      req.emit('drain')\n    })\n\n    return false\n  }\n\n  handleEnd(chunk, encoding, callback) {\n    debug('request end')\n    const { req } = this\n\n    // handle the different overloaded arg signatures\n    if (typeof chunk === 'function') {\n      callback = chunk\n      chunk = null\n    } else if (typeof encoding === 'function') {\n      callback = encoding\n      encoding = null\n    }\n\n    if (typeof callback === 'function') {\n      req.once('finish', callback)\n    }\n\n    if (chunk) {\n      req.write(chunk, encoding)\n    }\n    req.finished = true\n    this.maybeStartPlayback()\n\n    return req\n  }\n\n  handleFlushHeaders() {\n    debug('request flushHeaders')\n    this.maybeStartPlayback()\n  }\n\n  /**\n   * Set request headers of the given request. This is needed both during the\n   * routing phase, in case header filters were specified, and during the\n   * interceptor-playback phase, to correctly pass mocked request headers.\n   * TODO There are some problems with this; see https://github.com/nock/nock/issues/1718\n   */\n  setHostHeaderUsingInterceptor(interceptor) {\n    const { req, options } = this\n\n    // If a filtered scope is being used we have to use scope's host in the\n    // header, otherwise 'host' header won't match.\n    // NOTE: We use lower-case header field names throughout Nock.\n    const HOST_HEADER = 'host'\n    if (interceptor.__nock_filteredScope && interceptor.__nock_scopeHost) {\n      options.headers[HOST_HEADER] = interceptor.__nock_scopeHost\n      req.setHeader(HOST_HEADER, interceptor.__nock_scopeHost)\n    } else {\n      // For all other cases, we always add host header equal to the requested\n      // host unless it was already defined.\n      if (options.host && !req.getHeader(HOST_HEADER)) {\n        let hostHeader = options.host\n\n        if (options.port === 80 || options.port === 443) {\n          hostHeader = hostHeader.split(':')[0]\n        }\n\n        req.setHeader(HOST_HEADER, hostHeader)\n      }\n    }\n  }\n\n  maybeStartPlayback() {\n    const { req, socket, playbackStarted } = this\n\n    // In order to get the events in the right order we need to delay playback\n    // if we get here before the `socket` event is emitted.\n    if (socket.connecting) {\n      this.readyToStartPlaybackOnSocketEvent = true\n      return\n    }\n\n    if (!common.isRequestDestroyed(req) && !playbackStarted) {\n      this.startPlayback()\n    }\n  }\n\n  startPlayback() {\n    debug('ending')\n    this.playbackStarted = true\n\n    const { req, response, socket, options, interceptors } = this\n\n    Object.assign(options, {\n      // Re-update `options` with the current value of `req.path` because badly\n      // behaving agents like superagent like to change `req.path` mid-flight.\n      path: req.path,\n      // Similarly, node-http-proxy will modify headers in flight, so we have\n      // to put the headers back into options.\n      // https://github.com/nock/nock/pull/1484\n      headers: req.getHeaders(),\n      // Fixes https://github.com/nock/nock/issues/976\n      protocol: `${options.proto}:`,\n    })\n\n    interceptors.forEach(interceptor => {\n      this.setHostHeaderUsingInterceptor(interceptor)\n    })\n\n    const requestBodyBuffer = Buffer.concat(this.requestBodyBuffers)\n    // When request body is a binary buffer we internally use in its hexadecimal\n    // representation.\n    const requestBodyIsUtf8Representable = common.isUtf8Representable(\n      requestBodyBuffer\n    )\n    const requestBodyString = requestBodyBuffer.toString(\n      requestBodyIsUtf8Representable ? 'utf8' : 'hex'\n    )\n\n    const matchedInterceptor = interceptors.find(i =>\n      i.match(req, options, requestBodyString)\n    )\n\n    if (matchedInterceptor) {\n      matchedInterceptor.scope.logger(\n        'interceptor identified, starting mocking'\n      )\n\n      matchedInterceptor.markConsumed()\n\n      // wait to emit the finish event until we know for sure an Interceptor is going to playback.\n      // otherwise an unmocked request might emit finish twice.\n      req.emit('finish')\n\n      playbackInterceptor({\n        req,\n        socket,\n        options,\n        requestBodyString,\n        requestBodyIsUtf8Representable,\n        response,\n        interceptor: matchedInterceptor,\n      })\n    } else {\n      globalEmitter.emit('no match', req, options, requestBodyString)\n\n      // Try to find a hostname match that allows unmocked.\n      const allowUnmocked = interceptors.some(\n        i => i.matchHostName(options) && i.options.allowUnmocked\n      )\n\n      if (allowUnmocked && req instanceof ClientRequest) {\n        const newReq =\n          options.proto === 'https'\n            ? originalHttpsRequest(options)\n            : originalHttpRequest(options)\n\n        propagate(newReq, req)\n        // We send the raw buffer as we received it, not as we interpreted it.\n        newReq.end(requestBodyBuffer)\n      } else {\n        const reqStr = common.stringifyRequest(options, requestBodyString)\n        const err = new Error(`Nock: No match for request ${reqStr}`)\n        err.code = 'ERR_NOCK_NO_MATCH'\n        err.statusCode = err.status = 404\n        req.destroy(err)\n      }\n    }\n  }\n}\n\nmodule.exports = { InterceptedRequestRouter }\n"]}