{"version":3,"sources":["wait-for-element-to-be-removed.js"],"names":["Object","defineProperty","exports","value","waitForElementToBeRemoved","_waitFor","require","isRemoved","result","Array","isArray","length","initialCheck","elements","Error","callback","options","timeoutError","getRemainingElements","map","element","parent","parentElement","contains","c","filter","Boolean","waitFor","error","name","undefined"],"mappings":"AAAA;;;;;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,yBAAR,GAAoCA,yBAApC;;AAEA,IAAIC,QAAQ,GAAGC,OAAO,cAAtB;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,MAAM;AAAA,SAAI,CAACA,MAAD,IAAWC,KAAK,CAACC,OAAN,CAAcF,MAAd,KAAyB,CAACA,MAAM,CAACG,MAAhD;AAAA,CAAxB;;AAIA,SAASC,YAAT,CAAsBC,QAAtB,EAAgC;AAC9B,MAAIN,SAAS,CAACM,QAAD,CAAb,EAAyB;AACvB,UAAM,IAAIC,KAAJ,CAAU,oKAAV,CAAN;AACD;AACF;;AAED,SAAeV,yBAAf,CAAyCW,QAAzC,EAAmDC,OAAnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAEQC,UAAAA,YAFR,GAEuB,IAAIH,KAAJ,CAAU,yCAAV,CAFvB;;AAIE,cAAI,OAAOC,QAAP,KAAoB,UAAxB,EAAoC;AAClCH,YAAAA,YAAY,CAACG,QAAD,CAAZ;AACMF,YAAAA,QAF4B,GAEjBJ,KAAK,CAACC,OAAN,CAAcK,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAFpB;AAG5BG,YAAAA,oBAH4B,GAGLL,QAAQ,CAACM,GAAT,CAAa,UAAAC,OAAO,EAAI;AACnD,kBAAIC,MAAM,GAAGD,OAAO,CAACE,aAArB;AACA,kBAAID,MAAM,KAAK,IAAf,EAAqB,OAAO;AAAA,uBAAM,IAAN;AAAA,eAAP;;AAErB,qBAAOA,MAAM,CAACC,aAAd;AAA6BD,gBAAAA,MAAM,GAAGA,MAAM,CAACC,aAAhB;AAA7B;;AAEA,qBAAO;AAAA,uBAAMD,MAAM,CAACE,QAAP,CAAgBH,OAAhB,IAA2BA,OAA3B,GAAqC,IAA3C;AAAA,eAAP;AACD,aAP4B,CAHK;;AAYlCL,YAAAA,QAAQ,GAAG;AAAA,qBAAMG,oBAAoB,CAACC,GAArB,CAAyB,UAAAK,CAAC;AAAA,uBAAIA,CAAC,EAAL;AAAA,eAA1B,EAAmCC,MAAnC,CAA0CC,OAA1C,CAAN;AAAA,aAAX;AACD;;AAEDd,UAAAA,YAAY,CAACG,QAAQ,EAAT,CAAZ;AAnBF,2CAoBS,CAAC,GAAGV,QAAQ,CAACsB,OAAb,EAAsB,YAAM;AACjC,gBAAInB,MAAJ;;AAEA,gBAAI;AACFA,cAAAA,MAAM,GAAGO,QAAQ,EAAjB;AACD,aAFD,CAEE,OAAOa,KAAP,EAAc;AACd,kBAAIA,KAAK,CAACC,IAAN,KAAe,4BAAnB,EAAiD;AAC/C,uBAAOC,SAAP;AACD;;AAED,oBAAMF,KAAN;AACD;;AAED,gBAAI,CAACrB,SAAS,CAACC,MAAD,CAAd,EAAwB;AACtB,oBAAMS,YAAN;AACD;;AAED,mBAAOa,SAAP;AACD,WAlBM,EAkBJd,OAlBI,CApBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForElementToBeRemoved = waitForElementToBeRemoved;\n\nvar _waitFor = require(\"./wait-for\");\n\nconst isRemoved = result => !result || Array.isArray(result) && !result.length; // Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\n\n\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\n\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n\n      while (parent.parentElement) parent = parent.parentElement;\n\n      return () => parent.contains(element) ? element : null;\n    });\n\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n\n  initialCheck(callback());\n  return (0, _waitFor.waitFor)(() => {\n    let result;\n\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n\n      throw error;\n    }\n\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n\n    return undefined;\n  }, options);\n}\n/*\neslint\n  require-await: \"off\"\n*/"]}