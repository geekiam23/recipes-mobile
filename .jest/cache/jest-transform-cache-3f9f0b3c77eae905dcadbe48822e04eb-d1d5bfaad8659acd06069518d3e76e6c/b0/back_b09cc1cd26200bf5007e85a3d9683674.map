{"version":3,"sources":["back.js"],"names":["assert","require","recorder","activate","disableNetConnect","enableNetConnect","cleanAll","removeAll","loadDefs","define","format","path","debug","_mode","fs","err","Back","fixtureName","options","nockedFn","fixtures","Error","arguments","length","setup","fixture","join","context","start","nockDone","finish","call","Promise","resolve","wild","restore","load","dryrun","contexts","record","clear","isLoaded","dont_print","output_objects","isRecording","outputs","afterRecord","JSON","stringify","mkdirSync","dirname","recursive","writeFileSync","lockdown","scopes","assertScopesFinished","assertScopes","fixtureExists","applyHook","before","after","fn","forEach","existsSync","pending","filter","scope","isDone","map","pendingMocks","fail","concat","Modes","setMode","mode","currentMode","module","exports"],"mappings":"AAAA;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,QAAQ,GAAGD,OAAO,cAAxB;;AACA,eAKIA,OAAO,eALX;AAAA,IACEE,QADF,YACEA,QADF;AAAA,IAEEC,iBAFF,YAEEA,iBAFF;AAAA,IAGEC,gBAHF,YAGEA,gBAHF;AAAA,IAIaC,QAJb,YAIEC,SAJF;;AAMA,gBAA6BN,OAAO,WAApC;AAAA,IAAQO,QAAR,aAAQA,QAAR;AAAA,IAAkBC,MAAlB,aAAkBA,MAAlB;;AAEA,gBAAmBR,OAAO,CAAC,MAAD,CAA1B;AAAA,IAAQS,MAAR,aAAQA,MAAR;;AACA,IAAMC,IAAI,GAAGV,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMW,KAAK,GAAGX,OAAO,CAAC,OAAD,CAAP,CAAiB,WAAjB,CAAd;;AAEA,IAAIY,KAAK,GAAG,IAAZ;AAEA,IAAIC,EAAJ;;AAEA,IAAI;AACFA,EAAAA,EAAE,GAAGb,OAAO,CAAC,IAAD,CAAZ;AACD,CAFD,CAEE,OAAOc,GAAP,EAAY,CAEb;;AAsBD,SAASC,IAAT,CAAcC,WAAd,EAA2BC,OAA3B,EAAoCC,QAApC,EAA8C;AAC5C,MAAI,CAACH,IAAI,CAACI,QAAV,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CACJ,iDACE,OADF,GAEE,sDAHE,CAAN;AAKD;;AAED,MAAI,OAAOJ,WAAP,KAAuB,QAA3B,EAAqC;AACnC,UAAM,IAAII,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,MAAIC,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AAC1BL,IAAAA,OAAO,GAAG,EAAV;AACD,GAFD,MAEO,IAAII,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B;AAGjC,QAAI,OAAOL,OAAP,KAAmB,UAAvB,EAAmC;AACjCC,MAAAA,QAAQ,GAAGD,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;AACF;;AAEDL,EAAAA,KAAK,CAACW,KAAN;;AAEA,MAAMC,OAAO,GAAGd,IAAI,CAACe,IAAL,CAAUV,IAAI,CAACI,QAAf,EAAyBH,WAAzB,CAAhB;;AACA,MAAMU,OAAO,GAAGd,KAAK,CAACe,KAAN,CAAYH,OAAZ,EAAqBP,OAArB,CAAhB;;AAEA,MAAMW,QAAQ,GAAG,SAAXA,QAAW,GAAY;AAC3BhB,IAAAA,KAAK,CAACiB,MAAN,CAAaL,OAAb,EAAsBP,OAAtB,EAA+BS,OAA/B;AACD,GAFD;;AAIAf,EAAAA,KAAK,CAAC,UAAD,EAAae,OAAb,CAAL;;AAGA,MAAI,OAAOR,QAAP,KAAoB,UAAxB,EAAoC;AAClCA,IAAAA,QAAQ,CAACY,IAAT,CAAcJ,OAAd,EAAuBE,QAAvB;AACD,GAFD,MAEO;AACL,WAAOG,OAAO,CAACC,OAAR,CAAgB;AAAEJ,MAAAA,QAAQ,EAARA,QAAF;AAAYF,MAAAA,OAAO,EAAPA;AAAZ,KAAhB,CAAP;AACD;AACF;;AAMD,IAAMO,IAAI,GAAG;AACXV,EAAAA,KAAK,EAAE,iBAAY;AACjBlB,IAAAA,QAAQ;AACRJ,IAAAA,QAAQ,CAACiC,OAAT;AACAhC,IAAAA,QAAQ;AACRE,IAAAA,gBAAgB;AACjB,GANU;AAQXuB,EAAAA,KAAK,EAAE,iBAAY;AACjB,WAAOQ,IAAI,EAAX;AACD,GAVU;AAYXN,EAAAA,MAAM,EAAE,kBAAY,CAEnB;AAdU,CAAb;AAiBA,IAAMO,MAAM,GAAG;AACbb,EAAAA,KAAK,EAAE,iBAAY;AACjBtB,IAAAA,QAAQ,CAACiC,OAAT;AACA7B,IAAAA,QAAQ;AACRH,IAAAA,QAAQ;AAERE,IAAAA,gBAAgB;AACjB,GAPY;AASbuB,EAAAA,KAAK,EAAE,eAAUH,OAAV,EAAmBP,OAAnB,EAA4B;AACjC,QAAMoB,QAAQ,GAAGF,IAAI,CAACX,OAAD,EAAUP,OAAV,CAArB;AAEAb,IAAAA,gBAAgB;AAChB,WAAOiC,QAAP;AACD,GAdY;AAgBbR,EAAAA,MAAM,EAAE,kBAAY,CAEnB;AAlBY,CAAf;AAqBA,IAAMS,MAAM,GAAG;AACbf,EAAAA,KAAK,EAAE,iBAAY;AACjBtB,IAAAA,QAAQ,CAACiC,OAAT;AACAjC,IAAAA,QAAQ,CAACsC,KAAT;AACAlC,IAAAA,QAAQ;AACRH,IAAAA,QAAQ;AACRC,IAAAA,iBAAiB;AAClB,GAPY;AASbwB,EAAAA,KAAK,EAAE,eAAUH,OAAV,EAAmBP,OAAnB,EAA4B;AACjC,QAAI,CAACJ,EAAL,EAAS;AACP,YAAM,IAAIO,KAAJ,CAAU,OAAV,CAAN;AACD;;AACD,QAAMM,OAAO,GAAGS,IAAI,CAACX,OAAD,EAAUP,OAAV,CAApB;;AAEA,QAAI,CAACS,OAAO,CAACc,QAAb,EAAuB;AACrBvC,MAAAA,QAAQ,CAACqC,MAAT;AACEG,QAAAA,UAAU,EAAE,IADd;AAEEC,QAAAA,cAAc,EAAE;AAFlB,SAGKzB,OAAO,CAAChB,QAHb;AAMAyB,MAAAA,OAAO,CAACiB,WAAR,GAAsB,IAAtB;AACD;;AAED,WAAOjB,OAAP;AACD,GA1BY;AA4BbG,EAAAA,MAAM,EAAE,gBAAUL,OAAV,EAAmBP,OAAnB,EAA4BS,OAA5B,EAAqC;AAC3C,QAAIA,OAAO,CAACiB,WAAZ,EAAyB;AACvB,UAAIC,OAAO,GAAG3C,QAAQ,CAAC2C,OAAT,EAAd;;AAEA,UAAI,OAAO3B,OAAO,CAAC4B,WAAf,KAA+B,UAAnC,EAA+C;AAC7CD,QAAAA,OAAO,GAAG3B,OAAO,CAAC4B,WAAR,CAAoBD,OAApB,CAAV;AACD;;AAEDA,MAAAA,OAAO,GACL,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwCE,IAAI,CAACC,SAAL,CAAeH,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAD1C;AAEAjC,MAAAA,KAAK,CAAC,mBAAD,EAAsBiC,OAAtB,CAAL;AAEA/B,MAAAA,EAAE,CAACmC,SAAH,CAAatC,IAAI,CAACuC,OAAL,CAAazB,OAAb,CAAb,EAAoC;AAAE0B,QAAAA,SAAS,EAAE;AAAb,OAApC;AACArC,MAAAA,EAAE,CAACsC,aAAH,CAAiB3B,OAAjB,EAA0BoB,OAA1B;AACD;AACF;AA3CY,CAAf;AA8CA,IAAMQ,QAAQ,GAAG;AACf7B,EAAAA,KAAK,EAAE,iBAAY;AACjBtB,IAAAA,QAAQ,CAACiC,OAAT;AACAjC,IAAAA,QAAQ,CAACsC,KAAT;AACAlC,IAAAA,QAAQ;AACRH,IAAAA,QAAQ;AACRC,IAAAA,iBAAiB;AAClB,GAPc;AASfwB,EAAAA,KAAK,EAAE,eAAUH,OAAV,EAAmBP,OAAnB,EAA4B;AACjC,WAAOkB,IAAI,CAACX,OAAD,EAAUP,OAAV,CAAX;AACD,GAXc;AAafY,EAAAA,MAAM,EAAE,kBAAY,CAEnB;AAfc,CAAjB;;AAkBA,SAASM,IAAT,CAAcX,OAAd,EAAuBP,OAAvB,EAAgC;AAC9B,MAAMS,OAAO,GAAG;AACd2B,IAAAA,MAAM,EAAE,EADM;AAEdC,IAAAA,oBAAoB,EAAE,gCAAY;AAChCC,MAAAA,YAAY,CAAC,KAAKF,MAAN,EAAc7B,OAAd,CAAZ;AACD;AAJa,GAAhB;;AAOA,MAAIA,OAAO,IAAIgC,aAAa,CAAChC,OAAD,CAA5B,EAAuC;AACrC,QAAI6B,MAAM,GAAG9C,QAAQ,CAACiB,OAAD,CAArB;AACAiC,IAAAA,SAAS,CAACJ,MAAD,EAASpC,OAAO,CAACyC,MAAjB,CAAT;AAEAL,IAAAA,MAAM,GAAG7C,MAAM,CAAC6C,MAAD,CAAf;AACAI,IAAAA,SAAS,CAACJ,MAAD,EAASpC,OAAO,CAAC0C,KAAjB,CAAT;AAEAjC,IAAAA,OAAO,CAAC2B,MAAR,GAAiBA,MAAjB;AACA3B,IAAAA,OAAO,CAACc,QAAR,GAAmB,IAAnB;AACD;;AAED,SAAOd,OAAP;AACD;;AAED,SAAS+B,SAAT,CAAmBJ,MAAnB,EAA2BO,EAA3B,EAA+B;AAC7B,MAAI,CAACA,EAAL,EAAS;AACP;AACD;;AAED,MAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAC5B,UAAM,IAAIxC,KAAJ,CAAU,qCAAV,CAAN;AACD;;AAEDiC,EAAAA,MAAM,CAACQ,OAAP,CAAeD,EAAf;AACD;;AAED,SAASJ,aAAT,CAAuBhC,OAAvB,EAAgC;AAC9B,MAAI,CAACX,EAAL,EAAS;AACP,UAAM,IAAIO,KAAJ,CAAU,OAAV,CAAN;AACD;;AAED,SAAOP,EAAE,CAACiD,UAAH,CAActC,OAAd,CAAP;AACD;;AAED,SAAS+B,YAAT,CAAsBF,MAAtB,EAA8B7B,OAA9B,EAAuC;AACrC,MAAMuC,OAAO,GAAGV,MAAM,CACnBW,MADa,CACN,UAAAC,KAAK;AAAA,WAAI,CAACA,KAAK,CAACC,MAAN,EAAL;AAAA,GADC,EAEbC,GAFa,CAET,UAAAF,KAAK;AAAA,WAAIA,KAAK,CAACG,YAAN,EAAJ;AAAA,GAFI,CAAhB;;AAIA,MAAIL,OAAO,CAACzC,MAAZ,EAAoB;AAAA;;AAClBvB,IAAAA,MAAM,CAACsE,IAAP,CACE5D,MAAM,CACJ,2DADI,EAEJ,YAAG6D,MAAH,8CAAaP,OAAb,EAFI,EAGJvC,OAHI,CADR;AAOD;AACF;;AAED,IAAM+C,KAAK,GAAG;AACZtC,EAAAA,IAAI,EAAJA,IADY;AAGZG,EAAAA,MAAM,EAANA,MAHY;AAKZE,EAAAA,MAAM,EAANA,MALY;AAOZc,EAAAA,QAAQ,EAARA;AAPY,CAAd;;AAUArC,IAAI,CAACyD,OAAL,GAAe,UAAUC,IAAV,EAAgB;AAC7B,MAAI,EAAEA,IAAI,IAAIF,KAAV,CAAJ,EAAsB;AACpB,UAAM,IAAInD,KAAJ,oBAA2BqD,IAA3B,CAAN;AACD;;AAED1D,EAAAA,IAAI,CAAC2D,WAAL,GAAmBD,IAAnB;AACA9D,EAAAA,KAAK,CAAC,qBAAD,EAAwBI,IAAI,CAAC2D,WAA7B,CAAL;AAEA9D,EAAAA,KAAK,GAAG2D,KAAK,CAACE,IAAD,CAAb;;AACA7D,EAAAA,KAAK,CAACW,KAAN;AACD,CAVD;;AAYAR,IAAI,CAACI,QAAL,GAAgB,IAAhB;AACAJ,IAAI,CAAC2D,WAAL,GAAmB,IAAnB;AAEAC,MAAM,CAACC,OAAP,GAAiB7D,IAAjB","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst recorder = require('./recorder')\nconst {\n  activate,\n  disableNetConnect,\n  enableNetConnect,\n  removeAll: cleanAll,\n} = require('./intercept')\nconst { loadDefs, define } = require('./scope')\n\nconst { format } = require('util')\nconst path = require('path')\nconst debug = require('debug')('nock.back')\n\nlet _mode = null\n\nlet fs\n\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, probably in browser\n}\n\n/**\n * nock the current function with the fixture given\n *\n * @param {string}   fixtureName  - the name of the fixture, e.x. 'foo.json'\n * @param {object}   options      - [optional] extra options for nock with, e.x. `{ assert: true }`\n * @param {function} nockedFn     - [optional] callback function to be executed with the given fixture being loaded;\n *                                  if defined the function will be called with context `{ scopes: loaded_nocks || [] }`\n *                                  set as `this` and `nockDone` callback function as first and only parameter;\n *                                  if not defined a promise resolving to `{nockDone, context}` where `context` is\n *                                  aforementioned `{ scopes: loaded_nocks || [] }`\n *\n * List of options:\n *\n * @param {function} before       - a preprocessing function, gets called before nock.define\n * @param {function} after        - a postprocessing function, gets called after nock.define\n * @param {function} afterRecord  - a postprocessing function, gets called after recording. Is passed the array\n *                                  of scopes recorded and should return the array scopes to save to the fixture\n * @param {function} recorder     - custom options to pass to the recorder\n *\n */\nfunction Back(fixtureName, options, nockedFn) {\n  if (!Back.fixtures) {\n    throw new Error(\n      'Back requires nock.back.fixtures to be set\\n' +\n        'Ex:\\n' +\n        \"\\trequire(nock).back.fixtures = '/path/to/fixtures/'\"\n    )\n  }\n\n  if (typeof fixtureName !== 'string') {\n    throw new Error('Parameter fixtureName must be a string')\n  }\n\n  if (arguments.length === 1) {\n    options = {}\n  } else if (arguments.length === 2) {\n    // If 2nd parameter is a function then `options` has been omitted\n    // otherwise `options` haven't been omitted but `nockedFn` was.\n    if (typeof options === 'function') {\n      nockedFn = options\n      options = {}\n    }\n  }\n\n  _mode.setup()\n\n  const fixture = path.join(Back.fixtures, fixtureName)\n  const context = _mode.start(fixture, options)\n\n  const nockDone = function () {\n    _mode.finish(fixture, options, context)\n  }\n\n  debug('context:', context)\n\n  // If nockedFn is a function then invoke it, otherwise return a promise resolving to nockDone.\n  if (typeof nockedFn === 'function') {\n    nockedFn.call(context, nockDone)\n  } else {\n    return Promise.resolve({ nockDone, context })\n  }\n}\n\n/*******************************************************************************\n *                                    Modes                                     *\n *******************************************************************************/\n\nconst wild = {\n  setup: function () {\n    cleanAll()\n    recorder.restore()\n    activate()\n    enableNetConnect()\n  },\n\n  start: function () {\n    return load() // don't load anything but get correct context\n  },\n\n  finish: function () {\n    // nothing to do\n  },\n}\n\nconst dryrun = {\n  setup: function () {\n    recorder.restore()\n    cleanAll()\n    activate()\n    //  We have to explicitly enable net connectivity as by default it's off.\n    enableNetConnect()\n  },\n\n  start: function (fixture, options) {\n    const contexts = load(fixture, options)\n\n    enableNetConnect()\n    return contexts\n  },\n\n  finish: function () {\n    // nothing to do\n  },\n}\n\nconst record = {\n  setup: function () {\n    recorder.restore()\n    recorder.clear()\n    cleanAll()\n    activate()\n    disableNetConnect()\n  },\n\n  start: function (fixture, options) {\n    if (!fs) {\n      throw new Error('no fs')\n    }\n    const context = load(fixture, options)\n\n    if (!context.isLoaded) {\n      recorder.record({\n        dont_print: true,\n        output_objects: true,\n        ...options.recorder,\n      })\n\n      context.isRecording = true\n    }\n\n    return context\n  },\n\n  finish: function (fixture, options, context) {\n    if (context.isRecording) {\n      let outputs = recorder.outputs()\n\n      if (typeof options.afterRecord === 'function') {\n        outputs = options.afterRecord(outputs)\n      }\n\n      outputs =\n        typeof outputs === 'string' ? outputs : JSON.stringify(outputs, null, 4)\n      debug('recorder outputs:', outputs)\n\n      fs.mkdirSync(path.dirname(fixture), { recursive: true })\n      fs.writeFileSync(fixture, outputs)\n    }\n  },\n}\n\nconst lockdown = {\n  setup: function () {\n    recorder.restore()\n    recorder.clear()\n    cleanAll()\n    activate()\n    disableNetConnect()\n  },\n\n  start: function (fixture, options) {\n    return load(fixture, options)\n  },\n\n  finish: function () {\n    // nothing to do\n  },\n}\n\nfunction load(fixture, options) {\n  const context = {\n    scopes: [],\n    assertScopesFinished: function () {\n      assertScopes(this.scopes, fixture)\n    },\n  }\n\n  if (fixture && fixtureExists(fixture)) {\n    let scopes = loadDefs(fixture)\n    applyHook(scopes, options.before)\n\n    scopes = define(scopes)\n    applyHook(scopes, options.after)\n\n    context.scopes = scopes\n    context.isLoaded = true\n  }\n\n  return context\n}\n\nfunction applyHook(scopes, fn) {\n  if (!fn) {\n    return\n  }\n\n  if (typeof fn !== 'function') {\n    throw new Error('processing hooks must be a function')\n  }\n\n  scopes.forEach(fn)\n}\n\nfunction fixtureExists(fixture) {\n  if (!fs) {\n    throw new Error('no fs')\n  }\n\n  return fs.existsSync(fixture)\n}\n\nfunction assertScopes(scopes, fixture) {\n  const pending = scopes\n    .filter(scope => !scope.isDone())\n    .map(scope => scope.pendingMocks())\n\n  if (pending.length) {\n    assert.fail(\n      format(\n        '%j was not used, consider removing %s to rerecord fixture',\n        [].concat(...pending),\n        fixture\n      )\n    )\n  }\n}\n\nconst Modes = {\n  wild, // all requests go out to the internet, dont replay anything, doesnt record anything\n\n  dryrun, // use recorded nocks, allow http calls, doesnt record anything, useful for writing new tests (default)\n\n  record, // use recorded nocks, record new nocks\n\n  lockdown, // use recorded nocks, disables all http calls even when not nocked, doesnt record\n}\n\nBack.setMode = function (mode) {\n  if (!(mode in Modes)) {\n    throw new Error(`Unknown mode: ${mode}`)\n  }\n\n  Back.currentMode = mode\n  debug('New nock back mode:', Back.currentMode)\n\n  _mode = Modes[mode]\n  _mode.setup()\n}\n\nBack.fixtures = null\nBack.currentMode = null\n\nmodule.exports = Back\n"]}