{"version":3,"sources":["scope.js"],"names":["require","addInterceptor","isOn","common","assert","url","debug","EventEmitter","Interceptor","fs","err","Scope","basePath","options","keyedInterceptors","interceptors","transformPathFunction","transformRequestBodyFunction","matchHeaders","scopeOptions","urlParts","_persist","contentLen","date","basePathname","port","_defaultReplyHeaders","logNamespace","String","RegExp","parse","protocol","pathname","replace","hostname","host","logger","extend","key","interceptor","push","arr","splice","indexOf","length","uri","method","requestBody","interceptorOptions","ic","intercept","activeMocks","filter","some","interceptionCounter","optional","persistedAndUsed","Object","keys","pendingMocks","ok","isDone","join","filteringArguments","arguments","candidate","Error","buildFilter","apply","name","value","toLowerCase","headers","headersInputToRawArray","flag","d","Date","loadDefs","path","contents","readFileSync","JSON","load","define","getStatusFromDefinition","nockDef","reply","undefined","parsedReply","parseInt","isNaN","DEFAULT_STATUS_OK","status","getScopeFromDefinition","scope","tryJsonParse","string","nockDefs","scopes","forEach","nscope","npath","rawHeaders","reqheaders","badheaders","response","responseIsBinary","Buffer","from","entries","fieldName","matchHeader","acceptableFilters","body","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * @module nock/scope\n */\nconst { addInterceptor, isOn } = require('./intercept')\nconst common = require('./common')\nconst assert = require('assert')\nconst url = require('url')\nconst debug = require('debug')('nock.scope')\nconst { EventEmitter } = require('events')\nconst Interceptor = require('./interceptor')\n\nlet fs\n\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\n/**\n * @param  {string|RegExp|url.url} basePath\n * @param  {Object}   options\n * @param  {boolean}  options.allowUnmocked\n * @param  {string[]} options.badheaders\n * @param  {function} options.conditionally\n * @param  {boolean}  options.encodedQueryParams\n * @param  {function} options.filteringScope\n * @param  {Object}   options.reqheaders\n * @constructor\n */\nclass Scope extends EventEmitter {\n  constructor(basePath, options) {\n    super()\n\n    this.keyedInterceptors = {}\n    this.interceptors = []\n    this.transformPathFunction = null\n    this.transformRequestBodyFunction = null\n    this.matchHeaders = []\n    this.scopeOptions = options || {}\n    this.urlParts = {}\n    this._persist = false\n    this.contentLen = false\n    this.date = null\n    this.basePath = basePath\n    this.basePathname = ''\n    this.port = null\n    this._defaultReplyHeaders = []\n\n    let logNamespace = String(basePath)\n\n    if (!(basePath instanceof RegExp)) {\n      this.urlParts = url.parse(basePath)\n      this.port =\n        this.urlParts.port || (this.urlParts.protocol === 'http:' ? 80 : 443)\n      this.basePathname = this.urlParts.pathname.replace(/\\/$/, '')\n      this.basePath = `${this.urlParts.protocol}//${this.urlParts.hostname}:${this.port}`\n      logNamespace = this.urlParts.host\n    }\n\n    this.logger = debug.extend(logNamespace)\n  }\n\n  add(key, interceptor) {\n    if (!(key in this.keyedInterceptors)) {\n      this.keyedInterceptors[key] = []\n    }\n    this.keyedInterceptors[key].push(interceptor)\n    addInterceptor(\n      this.basePath,\n      interceptor,\n      this,\n      this.scopeOptions,\n      this.urlParts.hostname\n    )\n  }\n\n  remove(key, interceptor) {\n    if (this._persist) {\n      return\n    }\n    const arr = this.keyedInterceptors[key]\n    if (arr) {\n      arr.splice(arr.indexOf(interceptor), 1)\n      if (arr.length === 0) {\n        delete this.keyedInterceptors[key]\n      }\n    }\n  }\n\n  intercept(uri, method, requestBody, interceptorOptions) {\n    const ic = new Interceptor(\n      this,\n      uri,\n      method,\n      requestBody,\n      interceptorOptions\n    )\n\n    this.interceptors.push(ic)\n    return ic\n  }\n\n  get(uri, requestBody, options) {\n    return this.intercept(uri, 'GET', requestBody, options)\n  }\n\n  post(uri, requestBody, options) {\n    return this.intercept(uri, 'POST', requestBody, options)\n  }\n\n  put(uri, requestBody, options) {\n    return this.intercept(uri, 'PUT', requestBody, options)\n  }\n\n  head(uri, requestBody, options) {\n    return this.intercept(uri, 'HEAD', requestBody, options)\n  }\n\n  patch(uri, requestBody, options) {\n    return this.intercept(uri, 'PATCH', requestBody, options)\n  }\n\n  merge(uri, requestBody, options) {\n    return this.intercept(uri, 'MERGE', requestBody, options)\n  }\n\n  delete(uri, requestBody, options) {\n    return this.intercept(uri, 'DELETE', requestBody, options)\n  }\n\n  options(uri, requestBody, options) {\n    return this.intercept(uri, 'OPTIONS', requestBody, options)\n  }\n\n  // Returns the list of keys for non-optional Interceptors that haven't been completed yet.\n  // TODO: This assumes that completed mocks are removed from the keyedInterceptors list\n  // (when persistence is off). We should change that (and this) in future.\n  pendingMocks() {\n    return this.activeMocks().filter(key =>\n      this.keyedInterceptors[key].some(({ interceptionCounter, optional }) => {\n        const persistedAndUsed = this._persist && interceptionCounter > 0\n        return !persistedAndUsed && !optional\n      })\n    )\n  }\n\n  // Returns all keyedInterceptors that are active.\n  // This includes incomplete interceptors, persisted but complete interceptors, and\n  // optional interceptors, but not non-persisted and completed interceptors.\n  activeMocks() {\n    return Object.keys(this.keyedInterceptors)\n  }\n\n  isDone() {\n    if (!isOn()) {\n      return true\n    }\n\n    return this.pendingMocks().length === 0\n  }\n\n  done() {\n    assert.ok(\n      this.isDone(),\n      `Mocks not yet satisfied:\\n${this.pendingMocks().join('\\n')}`\n    )\n  }\n\n  buildFilter() {\n    const filteringArguments = arguments\n\n    if (arguments[0] instanceof RegExp) {\n      return function (candidate) {\n        /* istanbul ignore if */\n        if (typeof candidate !== 'string') {\n          // Given the way nock is written, it seems like `candidate` will always\n          // be a string, regardless of what options might be passed to it.\n          // However the code used to contain a truthiness test of `candidate`.\n          // The check is being preserved for now.\n          throw Error(\n            `Nock internal assertion failed: typeof candidate is ${typeof candidate}. If you encounter this error, please report it as a bug.`\n          )\n        }\n        return candidate.replace(filteringArguments[0], filteringArguments[1])\n      }\n    } else if (typeof arguments[0] === 'function') {\n      return arguments[0]\n    }\n  }\n\n  filteringPath() {\n    this.transformPathFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformPathFunction) {\n      throw new Error(\n        'Invalid arguments: filtering path should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  filteringRequestBody() {\n    this.transformRequestBodyFunction = this.buildFilter.apply(this, arguments)\n    if (!this.transformRequestBodyFunction) {\n      throw new Error(\n        'Invalid arguments: filtering request body should be a function or a regular expression'\n      )\n    }\n    return this\n  }\n\n  matchHeader(name, value) {\n    //  We use lower-case header field names throughout Nock.\n    this.matchHeaders.push({ name: name.toLowerCase(), value })\n    return this\n  }\n\n  defaultReplyHeaders(headers) {\n    this._defaultReplyHeaders = common.headersInputToRawArray(headers)\n    return this\n  }\n\n  persist(flag = true) {\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n    this._persist = flag\n    return this\n  }\n\n  /**\n   * @private\n   * @returns {boolean}\n   */\n  shouldPersist() {\n    return this._persist\n  }\n\n  replyContentLength() {\n    this.contentLen = true\n    return this\n  }\n\n  replyDate(d) {\n    this.date = d || new Date()\n    return this\n  }\n}\n\nfunction loadDefs(path) {\n  if (!fs) {\n    throw new Error('No fs')\n  }\n\n  const contents = fs.readFileSync(path)\n  return JSON.parse(contents)\n}\n\nfunction load(path) {\n  return define(loadDefs(path))\n}\n\nfunction getStatusFromDefinition(nockDef) {\n  // Backward compatibility for when `status` was encoded as string in `reply`.\n  if (nockDef.reply !== undefined) {\n    const parsedReply = parseInt(nockDef.reply, 10)\n    if (isNaN(parsedReply)) {\n      throw Error('`reply`, when present, must be a numeric string')\n    }\n\n    return parsedReply\n  }\n\n  const DEFAULT_STATUS_OK = 200\n  return nockDef.status || DEFAULT_STATUS_OK\n}\n\nfunction getScopeFromDefinition(nockDef) {\n  //  Backward compatibility for when `port` was part of definition.\n  if (nockDef.port !== undefined) {\n    //  Include `port` into scope if it doesn't exist.\n    const options = url.parse(nockDef.scope)\n    if (options.port === null) {\n      return `${nockDef.scope}:${nockDef.port}`\n    } else {\n      if (parseInt(options.port) !== parseInt(nockDef.port)) {\n        throw new Error(\n          'Mismatched port numbers in scope and port properties of nock definition.'\n        )\n      }\n    }\n  }\n\n  return nockDef.scope\n}\n\nfunction tryJsonParse(string) {\n  try {\n    return JSON.parse(string)\n  } catch (err) {\n    return string\n  }\n}\n\nfunction define(nockDefs) {\n  const scopes = []\n\n  nockDefs.forEach(function (nockDef) {\n    const nscope = getScopeFromDefinition(nockDef)\n    const npath = nockDef.path\n    if (!nockDef.method) {\n      throw Error('Method is required')\n    }\n    const method = nockDef.method.toLowerCase()\n    const status = getStatusFromDefinition(nockDef)\n    const rawHeaders = nockDef.rawHeaders || []\n    const reqheaders = nockDef.reqheaders || {}\n    const badheaders = nockDef.badheaders || []\n    const options = { ...nockDef.options }\n\n    //  We use request headers for both filtering (see below) and mocking.\n    //  Here we are setting up mocked request headers but we don't want to\n    //  be changing the user's options object so we clone it first.\n    options.reqheaders = reqheaders\n    options.badheaders = badheaders\n\n    // Response is not always JSON as it could be a string or binary data or\n    // even an array of binary buffers (e.g. when content is encoded).\n    let response\n    if (!nockDef.response) {\n      response = ''\n      // TODO: Rename `responseIsBinary` to `responseIsUtf8Representable`.\n    } else if (nockDef.responseIsBinary) {\n      response = Buffer.from(nockDef.response, 'hex')\n    } else {\n      response =\n        typeof nockDef.response === 'string'\n          ? tryJsonParse(nockDef.response)\n          : nockDef.response\n    }\n\n    const scope = new Scope(nscope, options)\n\n    // If request headers were specified filter by them.\n    Object.entries(reqheaders).forEach(([fieldName, value]) => {\n      scope.matchHeader(fieldName, value)\n    })\n\n    const acceptableFilters = ['filteringRequestBody', 'filteringPath']\n    acceptableFilters.forEach(filter => {\n      if (nockDef[filter]) {\n        scope[filter](nockDef[filter])\n      }\n    })\n\n    scope\n      .intercept(npath, method, nockDef.body)\n      .reply(status, response, rawHeaders)\n\n    scopes.push(scope)\n  })\n\n  return scopes\n}\n\nmodule.exports = {\n  Scope,\n  load,\n  loadDefs,\n  define,\n}\n"]}