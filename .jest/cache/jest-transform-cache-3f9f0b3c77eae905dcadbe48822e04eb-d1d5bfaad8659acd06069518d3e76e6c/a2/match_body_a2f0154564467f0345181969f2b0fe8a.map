{"version":3,"sources":["match_body.js"],"names":["querystring","require","common","module","exports","matchBody","options","spec","body","RegExp","test","Buffer","isBuffer","encoding","isUtf8Representable","toString","contentType","headers","isMultipart","includes","isUrlencoded","json","JSON","parse","err","undefined","call","replace","mapValuesDeep","val","dataEqual","obj","cb","Array","isArray","map","v","isPlainObject","mapValue"],"mappings":"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","sourcesContent":["'use strict'\n\nconst querystring = require('querystring')\n\nconst common = require('./common')\n\nmodule.exports = function matchBody(options, spec, body) {\n  if (spec instanceof RegExp) {\n    return spec.test(body)\n  }\n\n  if (Buffer.isBuffer(spec)) {\n    const encoding = common.isUtf8Representable(spec) ? 'utf8' : 'hex'\n    spec = spec.toString(encoding)\n  }\n\n  const contentType = (\n    (options.headers &&\n      (options.headers['Content-Type'] || options.headers['content-type'])) ||\n    ''\n  ).toString()\n\n  const isMultipart = contentType.includes('multipart')\n  const isUrlencoded = contentType.includes('application/x-www-form-urlencoded')\n\n  // try to transform body to json\n  let json\n  if (typeof spec === 'object' || typeof spec === 'function') {\n    try {\n      json = JSON.parse(body)\n    } catch (err) {\n      // not a valid JSON string\n    }\n    if (json !== undefined) {\n      body = json\n    } else if (isUrlencoded) {\n      body = querystring.parse(body)\n    }\n  }\n\n  if (typeof spec === 'function') {\n    return spec.call(options, body)\n  }\n\n  // strip line endings from both so that we get a match no matter what OS we are running on\n  // if Content-Type does not contains 'multipart'\n  if (!isMultipart && typeof body === 'string') {\n    body = body.replace(/\\r?\\n|\\r/g, '')\n  }\n\n  if (!isMultipart && typeof spec === 'string') {\n    spec = spec.replace(/\\r?\\n|\\r/g, '')\n  }\n\n  // Because the nature of URL encoding, all the values in the body have been cast to strings.\n  // dataEqual does strict checking so we we have to cast the non-regexp values in the spec too.\n  if (isUrlencoded) {\n    spec = mapValuesDeep(spec, val => (val instanceof RegExp ? val : `${val}`))\n  }\n\n  return common.dataEqual(spec, body)\n}\n\n/**\n * Based on lodash issue discussion\n * https://github.com/lodash/lodash/issues/1244\n */\nfunction mapValuesDeep(obj, cb) {\n  if (Array.isArray(obj)) {\n    return obj.map(v => mapValuesDeep(v, cb))\n  }\n  if (common.isPlainObject(obj)) {\n    return common.mapValue(obj, v => mapValuesDeep(v, cb))\n  }\n  return cb(obj)\n}\n"]}