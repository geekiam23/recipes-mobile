{"version":3,"sources":["recorder.js"],"names":["debug","require","querystring","inspect","common","restoreOverriddenClientRequest","SEPARATOR","recordingInProgress","outputs","getScope","options","normalizeRequestOptions","proto","host","port","normalizeOrigin","getMethod","method","getBodyFromChunks","chunks","headers","isContentEncoded","body","map","chunk","toString","mergedBuffer","Buffer","concat","isUtf8Representable","maybeStringifiedJson","JSON","parse","err","generateRequestAndResponseObject","req","bodyChunks","res","dataChunks","reqheaders","path","scope","status","statusCode","response","rawHeaders","undefined","responseIsBinary","generateRequestAndResponse","requestBody","responseBody","queryIndex","indexOf","queryObj","substring","queryStr","slice","replace","encodedQueryObj","key","formattedPair","formatQueryValue","percentEncode","lines","push","methodName","toLowerCase","stringify","Object","entries","forEach","fieldName","fieldValue","safeName","safeValue","stringifiedResponseBody","join","currentRecordingId","defaultRecordOptions","dont_print","enable_reqheaders_recording","logging","console","log","output_objects","use_separator","record","recOptions","Error","thisRecordingId","dontPrint","enableReqHeadersRecording","outputObjects","useSeparator","restoreOverriddenRequests","overrideRequests","overriddenRequest","rawArgs","normalizeClientRequestArgs","callback","_recording","once","getHeaders","deleteHeadersField","generateFn","out","encoding","setEncoding","newEncoding","apply","arguments","origResPush","data","from","call","recordChunk","isBuffer","oldWrite","write","oldEnd","end","restore","clear","module","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,eAAjB,CAAd;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,aAAD,CAA3B;;AACA,eAAoBA,OAAO,CAAC,MAAD,CAA3B;AAAA,IAAQE,OAAR,YAAQA,OAAR;;AAEA,IAAMC,MAAM,GAAGH,OAAO,YAAtB;;AACA,gBAA2CA,OAAO,eAAlD;AAAA,IAAQI,8BAAR,aAAQA,8BAAR;;AAEA,IAAMC,SAAS,GAAG,gCAAlB;AACA,IAAIC,mBAAmB,GAAG,KAA1B;AACA,IAAIC,QAAO,GAAG,EAAd;;AAEA,SAASC,QAAT,CAAkBC,OAAlB,EAA2B;AACzB,8BAA8BN,MAAM,CAACO,uBAAP,CAA+BD,OAA/B,CAA9B;AAAA,MAAQE,KAAR,yBAAQA,KAAR;AAAA,MAAeC,IAAf,yBAAeA,IAAf;AAAA,MAAqBC,IAArB,yBAAqBA,IAArB;;AACA,SAAOV,MAAM,CAACW,eAAP,CAAuBH,KAAvB,EAA8BC,IAA9B,EAAoCC,IAApC,CAAP;AACD;;AAED,SAASE,SAAT,CAAmBN,OAAnB,EAA4B;AAC1B,SAAOA,OAAO,CAACO,MAAR,IAAkB,KAAzB;AACD;;AAED,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,OAAnC,EAA4C;AAI1C,MAAIA,OAAO,IAAIhB,MAAM,CAACiB,gBAAP,CAAwBD,OAAxB,CAAf,EAAiD;AAC/C,WAAO;AACLE,MAAAA,IAAI,EAAEH,MAAM,CAACI,GAAP,CAAW,UAAAC,KAAK;AAAA,eAAIA,KAAK,CAACC,QAAN,CAAe,KAAf,CAAJ;AAAA,OAAhB;AADD,KAAP;AAGD;;AAED,MAAMC,YAAY,GAAGC,MAAM,CAACC,MAAP,CAAcT,MAAd,CAArB;AAMA,MAAMU,mBAAmB,GAAGzB,MAAM,CAACyB,mBAAP,CAA2BH,YAA3B,CAA5B;;AACA,MAAIG,mBAAJ,EAAyB;AACvB,QAAMC,oBAAoB,GAAGJ,YAAY,CAACD,QAAb,CAAsB,MAAtB,CAA7B;;AACA,QAAI;AACF,aAAO;AACLI,QAAAA,mBAAmB,EAAnBA,mBADK;AAELP,QAAAA,IAAI,EAAES,IAAI,CAACC,KAAL,CAAWF,oBAAX;AAFD,OAAP;AAID,KALD,CAKE,OAAOG,GAAP,EAAY;AACZ,aAAO;AACLJ,QAAAA,mBAAmB,EAAnBA,mBADK;AAELP,QAAAA,IAAI,EAAEQ;AAFD,OAAP;AAID;AACF,GAbD,MAaO;AACL,WAAO;AACLD,MAAAA,mBAAmB,EAAnBA,mBADK;AAELP,MAAAA,IAAI,EAAEI,YAAY,CAACD,QAAb,CAAsB,KAAtB;AAFD,KAAP;AAID;AACF;;AAED,SAASS,gCAAT,OAOG;AAAA,MANDC,GAMC,QANDA,GAMC;AAAA,MALDC,UAKC,QALDA,UAKC;AAAA,MAJD1B,OAIC,QAJDA,OAIC;AAAA,MAHD2B,GAGC,QAHDA,GAGC;AAAA,MAFDC,UAEC,QAFDA,UAEC;AAAA,MADDC,UACC,QADDA,UACC;;AACD,2BAAsCrB,iBAAiB,CACrDoB,UADqD,EAErDD,GAAG,CAACjB,OAFiD,CAAvD;AAAA,MAAQE,IAAR,sBAAQA,IAAR;AAAA,MAAcO,mBAAd,sBAAcA,mBAAd;;AAIAnB,EAAAA,OAAO,CAAC8B,IAAR,GAAeL,GAAG,CAACK,IAAnB;AAEA,SAAO;AACLC,IAAAA,KAAK,EAAEhC,QAAQ,CAACC,OAAD,CADV;AAELO,IAAAA,MAAM,EAAED,SAAS,CAACN,OAAD,CAFZ;AAGL8B,IAAAA,IAAI,EAAE9B,OAAO,CAAC8B,IAHT;AAKLlB,IAAAA,IAAI,EAAEJ,iBAAiB,CAACkB,UAAD,CAAjB,CAA8Bd,IAL/B;AAMLoB,IAAAA,MAAM,EAAEL,GAAG,CAACM,UANP;AAOLC,IAAAA,QAAQ,EAAEtB,IAPL;AAQLuB,IAAAA,UAAU,EAAER,GAAG,CAACQ,UARX;AASLN,IAAAA,UAAU,EAAEA,UAAU,IAAIO,SATrB;AAYLC,IAAAA,gBAAgB,EAAElB,mBAAmB,KAAK;AAZrC,GAAP;AAcD;;AAED,SAASmB,0BAAT,QAOG;AAAA,MANDb,GAMC,SANDA,GAMC;AAAA,MALDC,UAKC,SALDA,UAKC;AAAA,MAJD1B,OAIC,SAJDA,OAIC;AAAA,MAHD2B,GAGC,SAHDA,GAGC;AAAA,MAFDC,UAEC,SAFDA,UAEC;AAAA,MADDC,UACC,SADDA,UACC;AACD,MAAMU,WAAW,GAAG/B,iBAAiB,CAACkB,UAAD,CAAjB,CAA8Bd,IAAlD;AACA,MAAM4B,YAAY,GAAGhC,iBAAiB,CAACoB,UAAD,EAAaD,GAAG,CAACjB,OAAjB,CAAjB,CAA2CE,IAAhE;AAGA,MAAMkB,IAAN,GAAe9B,OAAf,CAAM8B,IAAN;AACA,MAAMW,UAAU,GAAGhB,GAAG,CAACK,IAAJ,CAASY,OAAT,CAAiB,GAAjB,CAAnB;AACA,MAAIC,QAAQ,GAAG,EAAf;;AACA,MAAIF,UAAU,KAAK,CAAC,CAApB,EAAuB;AAErBX,IAAAA,IAAI,GAAGA,IAAI,CAACc,SAAL,CAAe,CAAf,EAAkBH,UAAlB,CAAP;AAEA,QAAMI,QAAQ,GAAGpB,GAAG,CAACK,IAAJ,CAASgB,KAAT,CAAeL,UAAU,GAAG,CAA5B,CAAjB;AACAE,IAAAA,QAAQ,GAAGnD,WAAW,CAAC8B,KAAZ,CAAkBuB,QAAlB,CAAX;AACD;;AAGDf,EAAAA,IAAI,GAAGA,IAAI,CAACiB,OAAL,CAAa,IAAb,QAAP;AAGA,MAAMC,eAAe,GAAG,EAAxB;;AACA,OAAK,IAAMC,GAAX,IAAkBN,QAAlB,EAA4B;AAC1B,QAAMO,aAAa,GAAGxD,MAAM,CAACyD,gBAAP,CACpBF,GADoB,EAEpBN,QAAQ,CAACM,GAAD,CAFY,EAGpBvD,MAAM,CAAC0D,aAHa,CAAtB;AAKAJ,IAAAA,eAAe,CAACE,aAAa,CAAC,CAAD,CAAd,CAAf,GAAoCA,aAAa,CAAC,CAAD,CAAjD;AACD;;AAED,MAAMG,KAAK,GAAG,EAAd;AAGAA,EAAAA,KAAK,CAACC,IAAN,CAAW,EAAX;AAEA,MAAMvB,KAAK,GAAGhC,QAAQ,CAACC,OAAD,CAAtB;AACAqD,EAAAA,KAAK,CAACC,IAAN,YAAoBvB,KAApB;AAEA,MAAMwB,UAAU,GAAGjD,SAAS,CAACN,OAAD,CAAT,CAAmBwD,WAAnB,EAAnB;;AACA,MAAIjB,WAAJ,EAAiB;AACfc,IAAAA,KAAK,CAACC,IAAN,SAAiBC,UAAjB,UAAgCzB,IAAhC,WAA0CT,IAAI,CAACoC,SAAL,CAAelB,WAAf,CAA1C;AACD,GAFD,MAEO;AACLc,IAAAA,KAAK,CAACC,IAAN,SAAiBC,UAAjB,UAAgCzB,IAAhC;AACD;;AAED4B,EAAAA,MAAM,CAACC,OAAP,CAAe9B,UAAU,IAAI,EAA7B,EAAiC+B,OAAjC,CAAyC,iBAA6B;AAAA;AAAA,QAA3BC,SAA2B;AAAA,QAAhBC,UAAgB;;AACpE,QAAMC,QAAQ,GAAG1C,IAAI,CAACoC,SAAL,CAAeI,SAAf,CAAjB;AACA,QAAMG,SAAS,GAAG3C,IAAI,CAACoC,SAAL,CAAeK,UAAf,CAAlB;AACAT,IAAAA,KAAK,CAACC,IAAN,qBAA6BS,QAA7B,UAA0CC,SAA1C;AACD,GAJD;;AAMA,MAAIvB,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrBY,IAAAA,KAAK,CAACC,IAAN,eAAuBjC,IAAI,CAACoC,SAAL,CAAeT,eAAf,CAAvB;AACD;;AAED,MAAMf,UAAU,GAAGN,GAAG,CAACM,UAAJ,CAAelB,QAAf,EAAnB;AACA,MAAMkD,uBAAuB,GAAG5C,IAAI,CAACoC,SAAL,CAAejB,YAAf,CAAhC;AACA,MAAM9B,OAAO,GAAGjB,OAAO,CAACkC,GAAG,CAACQ,UAAL,CAAvB;AACAkB,EAAAA,KAAK,CAACC,IAAN,eAAuBrB,UAAvB,UAAsCgC,uBAAtC,UAAkEvD,OAAlE;AAEA,SAAO2C,KAAK,CAACa,IAAN,CAAW,IAAX,CAAP;AACD;;AAOD,IAAIC,kBAAkB,GAAG,CAAzB;AAEA,IAAMC,oBAAoB,GAAG;AAC3BC,EAAAA,UAAU,EAAE,KADe;AAE3BC,EAAAA,2BAA2B,EAAE,KAFF;AAG3BC,EAAAA,OAAO,EAAEC,OAAO,CAACC,GAHU;AAI3BC,EAAAA,cAAc,EAAE,KAJW;AAK3BC,EAAAA,aAAa,EAAE;AALY,CAA7B;;AAQA,SAASC,MAAT,CAAgBC,UAAhB,EAA4B;AAI1B,MAAIhF,mBAAJ,EAAyB;AACvB,UAAM,IAAIiF,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAEDjF,EAAAA,mBAAmB,GAAG,IAAtB;AAGAsE,EAAAA,kBAAkB,GAAGA,kBAAkB,GAAG,CAA1C;AACA,MAAMY,eAAe,GAAGZ,kBAAxB;;AAIA,MAAI,OAAOU,UAAP,KAAsB,SAA1B,EAAqC;AACnCA,IAAAA,UAAU,GAAG;AAAER,MAAAA,UAAU,EAAEQ;AAAd,KAAb;AACD;;AAEDA,EAAAA,UAAU,8BAAQT,oBAAR,EAAiCS,UAAjC,CAAV;AAEAvF,EAAAA,KAAK,CAAC,iBAAD,EAAoByF,eAApB,EAAqCF,UAArC,CAAL;AAEA,oBAMIA,UANJ;AAAA,MACcG,SADd,eACEX,UADF;AAAA,MAE+BY,yBAF/B,eAEEX,2BAFF;AAAA,MAGEC,OAHF,eAGEA,OAHF;AAAA,MAIkBW,aAJlB,eAIER,cAJF;AAAA,MAKiBS,YALjB,eAKER,aALF;AAQArF,EAAAA,KAAK,CAACyF,eAAD,EAAkB,oDAAlB,CAAL;AAKArF,EAAAA,MAAM,CAAC0F,yBAAP;AAEAzF,EAAAA,8BAA8B;AAG9BD,EAAAA,MAAM,CAAC2F,gBAAP,CAAwB,UAAUnF,KAAV,EAAiBoF,iBAAjB,EAAoCC,OAApC,EAA6C;AACnE,gCAA8B7F,MAAM,CAAC8F,0BAAP,OAAA9F,MAAM,mCAA+B6F,OAA/B,EAApC;AAAA,QAAQvF,OAAR,yBAAQA,OAAR;AAAA,QAAiByF,QAAjB,yBAAiBA,QAAjB;;AACA,QAAM/D,UAAU,GAAG,EAAnB;;AAKA,QAAI1B,OAAO,CAAC0F,UAAZ,EAAwB;AACtB,aAAOJ,iBAAiB,CAACtF,OAAD,EAAUyF,QAAV,CAAxB;AACD;;AACDzF,IAAAA,OAAO,CAAC0F,UAAR,GAAqB,IAArB;AAEA,QAAMjE,GAAG,GAAG6D,iBAAiB,CAACtF,OAAD,EAAU,UAAU2B,GAAV,EAAe;AACpDrC,MAAAA,KAAK,CAACyF,eAAD,EAAkB,cAAlB,EAAkC7E,KAAlC,EAAyC,mBAAzC,CAAL;AAGAyB,MAAAA,GAAG,CAACgE,IAAJ,CAAS,KAAT,EAAgB,YAAY;AAC1BrG,QAAAA,KAAK,CAACyF,eAAD,EAAkB7E,KAAlB,EAAyB,2BAAzB,CAAL;AAEA,YAAI2B,UAAJ;;AAEA,YAAIoD,yBAAJ,EAA+B;AAG7BpD,UAAAA,UAAU,GAAGJ,GAAG,CAACmE,UAAJ,EAAb;AACAlG,UAAAA,MAAM,CAACmG,kBAAP,CAA0BhE,UAA1B,EAAsC,YAAtC;AACD;;AAED,YAAMiE,UAAU,GAAGZ,aAAa,GAC5B1D,gCAD4B,GAE5Bc,0BAFJ;AAGA,YAAIyD,GAAG,GAAGD,UAAU,CAAC;AACnBrE,UAAAA,GAAG,EAAHA,GADmB;AAEnBC,UAAAA,UAAU,EAAVA,UAFmB;AAGnB1B,UAAAA,OAAO,EAAPA,OAHmB;AAInB2B,UAAAA,GAAG,EAAHA,GAJmB;AAKnBC,UAAAA,UAAU,EAAVA,UALmB;AAMnBC,UAAAA,UAAU,EAAVA;AANmB,SAAD,CAApB;AASAvC,QAAAA,KAAK,CAAC,MAAD,EAASyG,GAAT,CAAL;;AAUA,YAAIhB,eAAe,KAAKZ,kBAAxB,EAA4C;AAC1C7E,UAAAA,KAAK,CAAC,+CAAD,EAAkDyG,GAAlD,CAAL;AACA;AACD;;AAEDjG,QAAAA,QAAO,CAACwD,IAAR,CAAayC,GAAb;;AAEA,YAAI,CAACf,SAAL,EAAgB;AACd,cAAIG,YAAJ,EAAkB;AAChB,gBAAI,OAAOY,GAAP,KAAe,QAAnB,EAA6B;AAC3BA,cAAAA,GAAG,GAAG1E,IAAI,CAACoC,SAAL,CAAesC,GAAf,EAAoB,IAApB,EAA0B,CAA1B,CAAN;AACD;;AACDxB,YAAAA,OAAO,CAAC3E,SAAS,GAAGmG,GAAZ,GAAkBnG,SAAnB,CAAP;AACD,WALD,MAKO;AACL2E,YAAAA,OAAO,CAACwB,GAAD,CAAP;AACD;AACF;AACF,OAnDD;AAqDA,UAAIC,QAAJ;AAGA,UAAQC,WAAR,GAAwBtE,GAAxB,CAAQsE,WAAR;;AACAtE,MAAAA,GAAG,CAACsE,WAAJ,GAAkB,UAAUC,WAAV,EAAuB;AACvCF,QAAAA,QAAQ,GAAGE,WAAX;AACA,eAAOD,WAAW,CAACE,KAAZ,CAAkB,IAAlB,EAAwBC,SAAxB,CAAP;AACD,OAHD;;AAKA,UAAMxE,UAAU,GAAG,EAAnB;AAEA,UAAMyE,WAAW,GAAG1E,GAAG,CAAC2B,IAAxB;;AACA3B,MAAAA,GAAG,CAAC2B,IAAJ,GAAW,UAAUgD,IAAV,EAAgB;AACzB,YAAIA,IAAJ,EAAU;AACR,cAAIN,QAAJ,EAAc;AACZM,YAAAA,IAAI,GAAGrF,MAAM,CAACsF,IAAP,CAAYD,IAAZ,EAAkBN,QAAlB,CAAP;AACD;;AACDpE,UAAAA,UAAU,CAAC0B,IAAX,CAAgBgD,IAAhB;AACD;;AAED,eAAOD,WAAW,CAACG,IAAZ,CAAiB7E,GAAjB,EAAsB2E,IAAtB,CAAP;AACD,OATD;;AAWA,UAAIb,QAAJ,EAAc;AACZA,QAAAA,QAAQ,CAAC9D,GAAD,EAAM3B,OAAN,EAAeyF,QAAf,CAAR;AACD;;AAEDnG,MAAAA,KAAK,CAAC,kCAAD,CAAL;;AAMA,UAAIY,KAAK,KAAK,OAAd,EAAuB;AACrBF,QAAAA,OAAO,CAACE,KAAR,GAAgB,OAAhB;AACD;AACF,KA7F4B,CAA7B;;AA+FA,QAAMuG,WAAW,GAAG,SAAdA,WAAc,CAAC3F,KAAD,EAAQkF,QAAR,EAAqB;AACvC1G,MAAAA,KAAK,CAACyF,eAAD,EAAkB,KAAlB,EAAyB7E,KAAzB,EAAgC,YAAhC,CAAL;;AACA,UAAI,CAACe,MAAM,CAACyF,QAAP,CAAgB5F,KAAhB,CAAL,EAA6B;AAC3BA,QAAAA,KAAK,GAAGG,MAAM,CAACsF,IAAP,CAAYzF,KAAZ,EAAmBkF,QAAnB,CAAR;AACD;;AACDtE,MAAAA,UAAU,CAAC4B,IAAX,CAAgBxC,KAAhB;AACD,KAND;;AAQA,QAAM6F,QAAQ,GAAGlF,GAAG,CAACmF,KAArB;;AACAnF,IAAAA,GAAG,CAACmF,KAAJ,GAAY,UAAU9F,KAAV,EAAiBkF,QAAjB,EAA2B;AACrC,UAAI,OAAOlF,KAAP,KAAiB,WAArB,EAAkC;AAChC2F,QAAAA,WAAW,CAAC3F,KAAD,EAAQkF,QAAR,CAAX;AACAW,QAAAA,QAAQ,CAACR,KAAT,CAAe1E,GAAf,EAAoB2E,SAApB;AACD,OAHD,MAGO;AACL,cAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AACD;AACF,KAPD;;AAYA,QAAM+B,MAAM,GAAGpF,GAAG,CAACqF,GAAnB;;AACArF,IAAAA,GAAG,CAACqF,GAAJ,GAAU,UAAUhG,KAAV,EAAiBkF,QAAjB,EAA2BP,QAA3B,EAAqC;AAC7CnG,MAAAA,KAAK,CAAC,SAAD,CAAL;;AACA,UAAI,OAAOwB,KAAP,KAAiB,UAArB,EAAiC;AAC/B2E,QAAAA,QAAQ,GAAG3E,KAAX;AACAA,QAAAA,KAAK,GAAG,IAAR;AACD,OAHD,MAGO,IAAI,OAAOkF,QAAP,KAAoB,UAAxB,EAAoC;AACzCP,QAAAA,QAAQ,GAAGO,QAAX;AACAA,QAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,UAAIlF,KAAJ,EAAW;AACT2F,QAAAA,WAAW,CAAC3F,KAAD,EAAQkF,QAAR,CAAX;AACD;;AACDa,MAAAA,MAAM,CAACL,IAAP,CAAY/E,GAAZ,EAAiBX,KAAjB,EAAwBkF,QAAxB,EAAkCP,QAAlC;AACD,KAdD;;AAgBA,WAAOhE,GAAP;AACD,GAlJD;AAmJD;;AAGD,SAASsF,OAAT,GAAmB;AACjBzH,EAAAA,KAAK,CACH6E,kBADG,EAEH,oDAFG,CAAL;AAKAzE,EAAAA,MAAM,CAAC0F,yBAAP;AACAzF,EAAAA,8BAA8B;AAC9BE,EAAAA,mBAAmB,GAAG,KAAtB;AACD;;AAED,SAASmH,KAAT,GAAiB;AACflH,EAAAA,QAAO,GAAG,EAAV;AACD;;AAEDmH,MAAM,CAACC,OAAP,GAAiB;AACftC,EAAAA,MAAM,EAANA,MADe;AAEf9E,EAAAA,OAAO,EAAE;AAAA,WAAMA,QAAN;AAAA,GAFM;AAGfiH,EAAAA,OAAO,EAAPA,OAHe;AAIfC,EAAAA,KAAK,EAALA;AAJe,CAAjB","sourcesContent":["'use strict'\n\nconst debug = require('debug')('nock.recorder')\nconst querystring = require('querystring')\nconst { inspect } = require('util')\n\nconst common = require('./common')\nconst { restoreOverriddenClientRequest } = require('./intercept')\n\nconst SEPARATOR = '\\n<<<<<<-- cut here -->>>>>>\\n'\nlet recordingInProgress = false\nlet outputs = []\n\nfunction getScope(options) {\n  const { proto, host, port } = common.normalizeRequestOptions(options)\n  return common.normalizeOrigin(proto, host, port)\n}\n\nfunction getMethod(options) {\n  return options.method || 'GET'\n}\n\nfunction getBodyFromChunks(chunks, headers) {\n  // If we have headers and there is content-encoding it means that the body\n  // shouldn't be merged but instead persisted as an array of hex strings so\n  // that the response chunks can be mocked one by one.\n  if (headers && common.isContentEncoded(headers)) {\n    return {\n      body: chunks.map(chunk => chunk.toString('hex')),\n    }\n  }\n\n  const mergedBuffer = Buffer.concat(chunks)\n\n  // The merged buffer can be one of three things:\n  // 1. A UTF-8-representable string buffer which represents a JSON object.\n  // 2. A UTF-8-representable buffer which doesn't represent a JSON object.\n  // 3. A non-UTF-8-representable buffer which then has to be recorded as a hex string.\n  const isUtf8Representable = common.isUtf8Representable(mergedBuffer)\n  if (isUtf8Representable) {\n    const maybeStringifiedJson = mergedBuffer.toString('utf8')\n    try {\n      return {\n        isUtf8Representable,\n        body: JSON.parse(maybeStringifiedJson),\n      }\n    } catch (err) {\n      return {\n        isUtf8Representable,\n        body: maybeStringifiedJson,\n      }\n    }\n  } else {\n    return {\n      isUtf8Representable,\n      body: mergedBuffer.toString('hex'),\n    }\n  }\n}\n\nfunction generateRequestAndResponseObject({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const { body, isUtf8Representable } = getBodyFromChunks(\n    dataChunks,\n    res.headers\n  )\n  options.path = req.path\n\n  return {\n    scope: getScope(options),\n    method: getMethod(options),\n    path: options.path,\n    // Is it deliberate that `getBodyFromChunks()` is called a second time?\n    body: getBodyFromChunks(bodyChunks).body,\n    status: res.statusCode,\n    response: body,\n    rawHeaders: res.rawHeaders,\n    reqheaders: reqheaders || undefined,\n    // When content-encoding is enabled, isUtf8Representable is `undefined`,\n    // so we explicitly check for `false`.\n    responseIsBinary: isUtf8Representable === false,\n  }\n}\n\nfunction generateRequestAndResponse({\n  req,\n  bodyChunks,\n  options,\n  res,\n  dataChunks,\n  reqheaders,\n}) {\n  const requestBody = getBodyFromChunks(bodyChunks).body\n  const responseBody = getBodyFromChunks(dataChunks, res.headers).body\n\n  // Remove any query params from options.path so they can be added in the query() function\n  let { path } = options\n  const queryIndex = req.path.indexOf('?')\n  let queryObj = {}\n  if (queryIndex !== -1) {\n    // Remove the query from the path\n    path = path.substring(0, queryIndex)\n\n    const queryStr = req.path.slice(queryIndex + 1)\n    queryObj = querystring.parse(queryStr)\n  }\n\n  // Escape any single quotes in the path as the output uses them\n  path = path.replace(/'/g, `\\\\'`)\n\n  // Always encode the query parameters when recording.\n  const encodedQueryObj = {}\n  for (const key in queryObj) {\n    const formattedPair = common.formatQueryValue(\n      key,\n      queryObj[key],\n      common.percentEncode\n    )\n    encodedQueryObj[formattedPair[0]] = formattedPair[1]\n  }\n\n  const lines = []\n\n  // We want a leading newline.\n  lines.push('')\n\n  const scope = getScope(options)\n  lines.push(`nock('${scope}', {\"encodedQueryParams\":true})`)\n\n  const methodName = getMethod(options).toLowerCase()\n  if (requestBody) {\n    lines.push(`  .${methodName}('${path}', ${JSON.stringify(requestBody)})`)\n  } else {\n    lines.push(`  .${methodName}('${path}')`)\n  }\n\n  Object.entries(reqheaders || {}).forEach(([fieldName, fieldValue]) => {\n    const safeName = JSON.stringify(fieldName)\n    const safeValue = JSON.stringify(fieldValue)\n    lines.push(`  .matchHeader(${safeName}, ${safeValue})`)\n  })\n\n  if (queryIndex !== -1) {\n    lines.push(`  .query(${JSON.stringify(encodedQueryObj)})`)\n  }\n\n  const statusCode = res.statusCode.toString()\n  const stringifiedResponseBody = JSON.stringify(responseBody)\n  const headers = inspect(res.rawHeaders)\n  lines.push(`  .reply(${statusCode}, ${stringifiedResponseBody}, ${headers});`)\n\n  return lines.join('\\n')\n}\n\n//  This module variable is used to identify a unique recording ID in order to skip\n//  spurious requests that sometimes happen. This problem has been, so far,\n//  exclusively detected in nock's unit testing where 'checks if callback is specified'\n//  interferes with other tests as its t.end() is invoked without waiting for request\n//  to finish (which is the point of the test).\nlet currentRecordingId = 0\n\nconst defaultRecordOptions = {\n  dont_print: false,\n  enable_reqheaders_recording: false,\n  logging: console.log,\n  output_objects: false,\n  use_separator: true,\n}\n\nfunction record(recOptions) {\n  //  Trying to start recording with recording already in progress implies an error\n  //  in the recording configuration (double recording makes no sense and used to lead\n  //  to duplicates in output)\n  if (recordingInProgress) {\n    throw new Error('Nock recording already in progress')\n  }\n\n  recordingInProgress = true\n\n  // Set the new current recording ID and capture its value in this instance of record().\n  currentRecordingId = currentRecordingId + 1\n  const thisRecordingId = currentRecordingId\n\n  // Originally the parameter was a dont_print boolean flag.\n  // To keep the existing code compatible we take that case into account.\n  if (typeof recOptions === 'boolean') {\n    recOptions = { dont_print: recOptions }\n  }\n\n  recOptions = { ...defaultRecordOptions, ...recOptions }\n\n  debug('start recording', thisRecordingId, recOptions)\n\n  const {\n    dont_print: dontPrint,\n    enable_reqheaders_recording: enableReqHeadersRecording,\n    logging,\n    output_objects: outputObjects,\n    use_separator: useSeparator,\n  } = recOptions\n\n  debug(thisRecordingId, 'restoring overridden requests before new overrides')\n  //  To preserve backward compatibility (starting recording wasn't throwing if nock was already active)\n  //  we restore any requests that may have been overridden by other parts of nock (e.g. intercept)\n  //  NOTE: This is hacky as hell but it keeps the backward compatibility *and* allows correct\n  //    behavior in the face of other modules also overriding ClientRequest.\n  common.restoreOverriddenRequests()\n  //  We restore ClientRequest as it messes with recording of modules that also override ClientRequest (e.g. xhr2)\n  restoreOverriddenClientRequest()\n\n  //  We override the requests so that we can save information on them before executing.\n  common.overrideRequests(function (proto, overriddenRequest, rawArgs) {\n    const { options, callback } = common.normalizeClientRequestArgs(...rawArgs)\n    const bodyChunks = []\n\n    // Node 0.11 https.request calls http.request -- don't want to record things\n    // twice.\n    /* istanbul ignore if */\n    if (options._recording) {\n      return overriddenRequest(options, callback)\n    }\n    options._recording = true\n\n    const req = overriddenRequest(options, function (res) {\n      debug(thisRecordingId, 'intercepting', proto, 'request to record')\n\n      //  We put our 'end' listener to the front of the listener array.\n      res.once('end', function () {\n        debug(thisRecordingId, proto, 'intercepted request ended')\n\n        let reqheaders\n        // Ignore request headers completely unless it was explicitly enabled by the user (see README)\n        if (enableReqHeadersRecording) {\n          // We never record user-agent headers as they are worse than useless -\n          // they actually make testing more difficult without providing any benefit (see README)\n          reqheaders = req.getHeaders()\n          common.deleteHeadersField(reqheaders, 'user-agent')\n        }\n\n        const generateFn = outputObjects\n          ? generateRequestAndResponseObject\n          : generateRequestAndResponse\n        let out = generateFn({\n          req,\n          bodyChunks,\n          options,\n          res,\n          dataChunks,\n          reqheaders,\n        })\n\n        debug('out:', out)\n\n        //  Check that the request was made during the current recording.\n        //  If it hasn't then skip it. There is no other simple way to handle\n        //  this as it depends on the timing of requests and responses. Throwing\n        //  will make some recordings/unit tests fail randomly depending on how\n        //  fast/slow the response arrived.\n        //  If you are seeing this error then you need to make sure that all\n        //  the requests made during a single recording session finish before\n        //  ending the same recording session.\n        if (thisRecordingId !== currentRecordingId) {\n          debug('skipping recording of an out-of-order request', out)\n          return\n        }\n\n        outputs.push(out)\n\n        if (!dontPrint) {\n          if (useSeparator) {\n            if (typeof out !== 'string') {\n              out = JSON.stringify(out, null, 2)\n            }\n            logging(SEPARATOR + out + SEPARATOR)\n          } else {\n            logging(out)\n          }\n        }\n      })\n\n      let encoding\n      // We need to be aware of changes to the stream's encoding so that we\n      // don't accidentally mangle the data.\n      const { setEncoding } = res\n      res.setEncoding = function (newEncoding) {\n        encoding = newEncoding\n        return setEncoding.apply(this, arguments)\n      }\n\n      const dataChunks = []\n      // Replace res.push with our own implementation that stores chunks\n      const origResPush = res.push\n      res.push = function (data) {\n        if (data) {\n          if (encoding) {\n            data = Buffer.from(data, encoding)\n          }\n          dataChunks.push(data)\n        }\n\n        return origResPush.call(res, data)\n      }\n\n      if (callback) {\n        callback(res, options, callback)\n      }\n\n      debug('finished setting up intercepting')\n\n      // We override both the http and the https modules; when we are\n      // serializing the request, we need to know which was called.\n      // By stuffing the state, we can make sure that nock records\n      // the intended protocol.\n      if (proto === 'https') {\n        options.proto = 'https'\n      }\n    })\n\n    const recordChunk = (chunk, encoding) => {\n      debug(thisRecordingId, 'new', proto, 'body chunk')\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk, encoding)\n      }\n      bodyChunks.push(chunk)\n    }\n\n    const oldWrite = req.write\n    req.write = function (chunk, encoding) {\n      if (typeof chunk !== 'undefined') {\n        recordChunk(chunk, encoding)\n        oldWrite.apply(req, arguments)\n      } else {\n        throw new Error('Data was undefined.')\n      }\n    }\n\n    // Starting in Node 8, `OutgoingMessage.end()` directly calls an internal\n    // `write_` function instead of proxying to the public\n    // `OutgoingMessage.write()` method, so we have to wrap `end` too.\n    const oldEnd = req.end\n    req.end = function (chunk, encoding, callback) {\n      debug('req.end')\n      if (typeof chunk === 'function') {\n        callback = chunk\n        chunk = null\n      } else if (typeof encoding === 'function') {\n        callback = encoding\n        encoding = null\n      }\n\n      if (chunk) {\n        recordChunk(chunk, encoding)\n      }\n      oldEnd.call(req, chunk, encoding, callback)\n    }\n\n    return req\n  })\n}\n\n// Restore *all* the overridden http/https modules' properties.\nfunction restore() {\n  debug(\n    currentRecordingId,\n    'restoring all the overridden http/https properties'\n  )\n\n  common.restoreOverriddenRequests()\n  restoreOverriddenClientRequest()\n  recordingInProgress = false\n}\n\nfunction clear() {\n  outputs = []\n}\n\nmodule.exports = {\n  record,\n  outputs: () => outputs,\n  restore,\n  clear,\n}\n"]}