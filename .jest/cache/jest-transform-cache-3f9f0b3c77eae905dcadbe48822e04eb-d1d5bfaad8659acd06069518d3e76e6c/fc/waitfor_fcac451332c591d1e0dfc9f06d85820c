17c8293d3f4632f576be5e58b433d5ff
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitFor = waitForWrapper;

var _helpers = require("./helpers");

var _config = require("./config");

function copyStackTrace(target, source) {
  target.stack = source.stack.replace(source.message, target.message);
}

function waitFor(callback, _ref) {
  var _ref$container = _ref.container,
      container = _ref$container === void 0 ? (0, _helpers.getDocument)() : _ref$container,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? (0, _config.getConfig)().asyncUtilTimeout : _ref$timeout,
      _ref$showOriginalStac = _ref.showOriginalStackTrace,
      showOriginalStackTrace = _ref$showOriginalStac === void 0 ? (0, _config.getConfig)().showOriginalStackTrace : _ref$showOriginalStac,
      stackTraceError = _ref.stackTraceError,
      _ref$interval = _ref.interval,
      interval = _ref$interval === void 0 ? 50 : _ref$interval,
      _ref$onTimeout = _ref.onTimeout,
      onTimeout = _ref$onTimeout === void 0 ? function (error) {
    error.message = (0, _config.getConfig)().getElementError(error.message, container).message;
    return error;
  } : _ref$onTimeout,
      _ref$mutationObserver = _ref.mutationObserverOptions,
      mutationObserverOptions = _ref$mutationObserver === void 0 ? {
    subtree: true,
    childList: true,
    attributes: true,
    characterData: true
  } : _ref$mutationObserver;

  if (typeof callback !== 'function') {
    throw new TypeError('Received `callback` arg must be a function');
  }

  return new Promise(function _callee(resolve, reject) {
    var lastError, intervalId, observer, finished, promiseStatus, overallTimeoutTimer, usingJestFakeTimers, error, _ref2, MutationObserver, onDone, checkRealTimersCallback, checkCallback, handleTimeout;

    return _regenerator.default.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            handleTimeout = function _handleTimeout() {
              var error;

              if (lastError) {
                error = lastError;

                if (!showOriginalStackTrace && error.name === 'TestingLibraryElementError') {
                  copyStackTrace(error, stackTraceError);
                }
              } else {
                error = new Error('Timed out in waitFor.');

                if (!showOriginalStackTrace) {
                  copyStackTrace(error, stackTraceError);
                }
              }

              onDone(onTimeout(error), null);
            };

            checkCallback = function _checkCallback() {
              if (promiseStatus === 'pending') return;

              try {
                var result = (0, _config.runWithExpensiveErrorDiagnosticsDisabled)(callback);

                if (typeof (result == null ? void 0 : result.then) === 'function') {
                  promiseStatus = 'pending';
                  result.then(function (resolvedValue) {
                    promiseStatus = 'resolved';
                    onDone(null, resolvedValue);
                  }, function (rejectedValue) {
                    promiseStatus = 'rejected';
                    lastError = rejectedValue;
                  });
                } else {
                  onDone(null, result);
                }
              } catch (error) {
                lastError = error;
              }
            };

            checkRealTimersCallback = function _checkRealTimersCallb() {
              if ((0, _helpers.jestFakeTimersAreEnabled)()) {
                var _error = new Error("Changed from using real timers to fake timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to fake timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");

                if (!showOriginalStackTrace) copyStackTrace(_error, stackTraceError);
                return reject(_error);
              } else {
                return checkCallback();
              }
            };

            onDone = function _onDone(error, result) {
              finished = true;
              clearTimeout(overallTimeoutTimer);

              if (!usingJestFakeTimers) {
                clearInterval(intervalId);
                observer.disconnect();
              }

              if (error) {
                reject(error);
              } else {
                resolve(result);
              }
            };

            finished = false;
            promiseStatus = 'idle';
            overallTimeoutTimer = setTimeout(handleTimeout, timeout);
            usingJestFakeTimers = (0, _helpers.jestFakeTimersAreEnabled)();

            if (!usingJestFakeTimers) {
              _context.next = 24;
              break;
            }

            checkCallback();

          case 10:
            if (finished) {
              _context.next = 22;
              break;
            }

            if ((0, _helpers.jestFakeTimersAreEnabled)()) {
              _context.next = 16;
              break;
            }

            error = new Error("Changed from using fake timers to real timers while using waitFor. This is not allowed and will result in very strange behavior. Please ensure you're awaiting all async things your test is doing before changing to real timers. For more info, please go to https://github.com/testing-library/dom-testing-library/issues/830");
            if (!showOriginalStackTrace) copyStackTrace(error, stackTraceError);
            reject(error);
            return _context.abrupt("return");

          case 16:
            jest.advanceTimersByTime(interval);
            checkCallback();
            _context.next = 20;
            return _regenerator.default.awrap(new Promise(function (r) {
              setTimeout(r, 0);
              jest.advanceTimersByTime(0);
            }));

          case 20:
            _context.next = 10;
            break;

          case 22:
            _context.next = 37;
            break;

          case 24:
            _context.prev = 24;
            (0, _helpers.checkContainerType)(container);
            _context.next = 32;
            break;

          case 28:
            _context.prev = 28;
            _context.t0 = _context["catch"](24);
            reject(_context.t0);
            return _context.abrupt("return");

          case 32:
            intervalId = setInterval(checkRealTimersCallback, interval);
            _ref2 = (0, _helpers.getWindowFromNode)(container), MutationObserver = _ref2.MutationObserver;
            observer = new MutationObserver(checkRealTimersCallback);
            observer.observe(container, mutationObserverOptions);
            checkCallback();

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, null, null, [[24, 28]], Promise);
  });
}

function waitForWrapper(callback, options) {
  var stackTraceError = new Error('STACK_TRACE_MESSAGE');
  return (0, _config.getConfig)().asyncWrapper(function () {
    return waitFor(callback, (0, _extends2.default)({
      stackTraceError: stackTraceError
    }, options));
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndhaXQtZm9yLmpzIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwid2FpdEZvciIsIndhaXRGb3JXcmFwcGVyIiwiX2hlbHBlcnMiLCJyZXF1aXJlIiwiX2NvbmZpZyIsImNvcHlTdGFja1RyYWNlIiwidGFyZ2V0Iiwic291cmNlIiwic3RhY2siLCJyZXBsYWNlIiwibWVzc2FnZSIsImNhbGxiYWNrIiwiY29udGFpbmVyIiwiZ2V0RG9jdW1lbnQiLCJ0aW1lb3V0IiwiZ2V0Q29uZmlnIiwiYXN5bmNVdGlsVGltZW91dCIsInNob3dPcmlnaW5hbFN0YWNrVHJhY2UiLCJzdGFja1RyYWNlRXJyb3IiLCJpbnRlcnZhbCIsIm9uVGltZW91dCIsImVycm9yIiwiZ2V0RWxlbWVudEVycm9yIiwibXV0YXRpb25PYnNlcnZlck9wdGlvbnMiLCJzdWJ0cmVlIiwiY2hpbGRMaXN0IiwiYXR0cmlidXRlcyIsImNoYXJhY3RlckRhdGEiLCJUeXBlRXJyb3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uRG9uZSIsImNoZWNrUmVhbFRpbWVyc0NhbGxiYWNrIiwiY2hlY2tDYWxsYmFjayIsImhhbmRsZVRpbWVvdXQiLCJsYXN0RXJyb3IiLCJuYW1lIiwiRXJyb3IiLCJwcm9taXNlU3RhdHVzIiwicmVzdWx0IiwicnVuV2l0aEV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3NEaXNhYmxlZCIsInRoZW4iLCJyZXNvbHZlZFZhbHVlIiwicmVqZWN0ZWRWYWx1ZSIsImplc3RGYWtlVGltZXJzQXJlRW5hYmxlZCIsImZpbmlzaGVkIiwiY2xlYXJUaW1lb3V0Iiwib3ZlcmFsbFRpbWVvdXRUaW1lciIsInVzaW5nSmVzdEZha2VUaW1lcnMiLCJjbGVhckludGVydmFsIiwiaW50ZXJ2YWxJZCIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsInNldFRpbWVvdXQiLCJqZXN0IiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsInIiLCJjaGVja0NvbnRhaW5lclR5cGUiLCJzZXRJbnRlcnZhbCIsImdldFdpbmRvd0Zyb21Ob2RlIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJvcHRpb25zIiwiYXN5bmNXcmFwcGVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sQ0FBQ0UsT0FBUixHQUFrQkMsY0FBbEI7O0FBRUEsSUFBSUMsUUFBUSxHQUFHQyxPQUFPLGFBQXRCOztBQUVBLElBQUlDLE9BQU8sR0FBR0QsT0FBTyxZQUFyQjs7QUFJQSxTQUFTRSxjQUFULENBQXdCQyxNQUF4QixFQUFnQ0MsTUFBaEMsRUFBd0M7QUFDdENELEVBQUFBLE1BQU0sQ0FBQ0UsS0FBUCxHQUFlRCxNQUFNLENBQUNDLEtBQVAsQ0FBYUMsT0FBYixDQUFxQkYsTUFBTSxDQUFDRyxPQUE1QixFQUFxQ0osTUFBTSxDQUFDSSxPQUE1QyxDQUFmO0FBQ0Q7O0FBRUQsU0FBU1YsT0FBVCxDQUFpQlcsUUFBakIsUUFnQkc7QUFBQSw0QkFmREMsU0FlQztBQUFBLE1BZkRBLFNBZUMsK0JBZlcsQ0FBQyxHQUFHVixRQUFRLENBQUNXLFdBQWIsR0FlWDtBQUFBLDBCQWREQyxPQWNDO0FBQUEsTUFkREEsT0FjQyw2QkFkUyxDQUFDLEdBQUdWLE9BQU8sQ0FBQ1csU0FBWixJQUF5QkMsZ0JBY2xDO0FBQUEsbUNBYkRDLHNCQWFDO0FBQUEsTUFiREEsc0JBYUMsc0NBYndCLENBQUMsR0FBR2IsT0FBTyxDQUFDVyxTQUFaLElBQXlCRSxzQkFhakQ7QUFBQSxNQVpEQyxlQVlDLFFBWkRBLGVBWUM7QUFBQSwyQkFYREMsUUFXQztBQUFBLE1BWERBLFFBV0MsOEJBWFUsRUFXVjtBQUFBLDRCQVZEQyxTQVVDO0FBQUEsTUFWREEsU0FVQywrQkFWVyxVQUFBQyxLQUFLLEVBQUk7QUFDbkJBLElBQUFB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RE8sTUFBQUEsZUFBZSxFQUFmQTtBQUR3RCxPQUVyRDZDLE9BRnFELEVBQWI7QUFBQSxHQUF0QyxDQUFQO0FBSUQiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMud2FpdEZvciA9IHdhaXRGb3JXcmFwcGVyO1xuXG52YXIgX2hlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuXG52YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxuLy8gVGhpcyBpcyBzbyB0aGUgc3RhY2sgdHJhY2UgdGhlIGRldmVsb3BlciBzZWVzIGlzIG9uZSB0aGF0J3Ncbi8vIGNsb3NlciB0byB0aGVpciBjb2RlIChiZWNhdXNlIGFzeW5jIHN0YWNrIHRyYWNlcyBhcmUgaGFyZCB0byBmb2xsb3cpLlxuZnVuY3Rpb24gY29weVN0YWNrVHJhY2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0LnN0YWNrID0gc291cmNlLnN0YWNrLnJlcGxhY2Uoc291cmNlLm1lc3NhZ2UsIHRhcmdldC5tZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FpdEZvcihjYWxsYmFjaywge1xuICBjb250YWluZXIgPSAoMCwgX2hlbHBlcnMuZ2V0RG9jdW1lbnQpKCksXG4gIHRpbWVvdXQgPSAoMCwgX2NvbmZpZy5nZXRDb25maWcpKCkuYXN5bmNVdGlsVGltZW91dCxcbiAgc2hvd09yaWdpbmFsU3RhY2tUcmFjZSA9ICgwLCBfY29uZmlnLmdldENvbmZpZykoKS5zaG93T3JpZ2luYWxTdGFja1RyYWNlLFxuICBzdGFja1RyYWNlRXJyb3IsXG4gIGludGVydmFsID0gNTAsXG4gIG9uVGltZW91dCA9IGVycm9yID0+IHtcbiAgICBlcnJvci5tZXNzYWdlID0gKDAsIF9jb25maWcuZ2V0Q29uZmlnKSgpLmdldEVsZW1lbnRFcnJvcihlcnJvci5tZXNzYWdlLCBjb250YWluZXIpLm1lc3NhZ2U7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9LFxuICBtdXRhdGlvbk9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICBzdWJ0cmVlOiB0cnVlLFxuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfVxufSkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVjZWl2ZWQgYGNhbGxiYWNrYCBhcmcgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBsYXN0RXJyb3IsIGludGVydmFsSWQsIG9ic2VydmVyO1xuICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBwcm9taXNlU3RhdHVzID0gJ2lkbGUnO1xuICAgIGNvbnN0IG92ZXJhbGxUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHRpbWVvdXQpO1xuICAgIGNvbnN0IHVzaW5nSmVzdEZha2VUaW1lcnMgPSAoMCwgX2hlbHBlcnMuamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKSgpO1xuXG4gICAgaWYgKHVzaW5nSmVzdEZha2VUaW1lcnMpIHtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTsgLy8gdGhpcyBpcyBhIGRhbmdlcm91cyBydWxlIHRvIGRpc2FibGUgYmVjYXVzZSBpdCBjb3VsZCBsZWFkIHRvIGFuXG4gICAgICAvLyBpbmZpbml0ZSBsb29wLiBIb3dldmVyLCBlc2xpbnQgaXNuJ3Qgc21hcnQgZW5vdWdoIHRvIGtub3cgdGhhdCB3ZSdyZVxuICAgICAgLy8gc2V0dGluZyBmaW5pc2hlZCBpbnNpZGUgYG9uRG9uZWAgd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2hlbiB3ZSdyZSBkb25lXG4gICAgICAvLyB3YWl0aW5nIG9yIHdoZW4gd2UndmUgdGltZWQgb3V0LlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb25cblxuICAgICAgd2hpbGUgKCFmaW5pc2hlZCkge1xuICAgICAgICBpZiAoISgwLCBfaGVscGVycy5qZXN0RmFrZVRpbWVyc0FyZUVuYWJsZWQpKCkpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQ2hhbmdlZCBmcm9tIHVzaW5nIGZha2UgdGltZXJzIHRvIHJlYWwgdGltZXJzIHdoaWxlIHVzaW5nIHdhaXRGb3IuIFRoaXMgaXMgbm90IGFsbG93ZWQgYW5kIHdpbGwgcmVzdWx0IGluIHZlcnkgc3RyYW5nZSBiZWhhdmlvci4gUGxlYXNlIGVuc3VyZSB5b3UncmUgYXdhaXRpbmcgYWxsIGFzeW5jIHRoaW5ncyB5b3VyIHRlc3QgaXMgZG9pbmcgYmVmb3JlIGNoYW5naW5nIHRvIHJlYWwgdGltZXJzLiBGb3IgbW9yZSBpbmZvLCBwbGVhc2UgZ28gdG8gaHR0cHM6Ly9naXRodWIuY29tL3Rlc3RpbmctbGlicmFyeS9kb20tdGVzdGluZy1saWJyYXJ5L2lzc3Vlcy84MzBgKTtcbiAgICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UpIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHdlICpjb3VsZCogKG1heWJlIHNob3VsZD8pIHVzZSBgYWR2YW5jZVRpbWVyc1RvTmV4dFRpbWVyYCBidXQgaXQnc1xuICAgICAgICAvLyBwb3NzaWJsZSB0aGF0IGNvdWxkIG1ha2UgdGhpcyBsb29wIGdvIG9uIGZvcmV2ZXIgaWYgc29tZW9uZSBpcyB1c2luZ1xuICAgICAgICAvLyB0aGlyZCBwYXJ0eSBjb2RlIHRoYXQncyBzZXR0aW5nIHVwIHJlY3Vyc2l2ZSB0aW1lcnMgc28gcmFwaWRseSB0aGF0XG4gICAgICAgIC8vIHRoZSB1c2VyJ3MgdGltZXIncyBkb24ndCBnZXQgYSBjaGFuY2UgdG8gcmVzb2x2ZS4gU28gd2UnbGwgYWR2YW5jZVxuICAgICAgICAvLyBieSBhbiBpbnRlcnZhbCBpbnN0ZWFkLiAoV2UgaGF2ZSBhIHRlc3QgZm9yIHRoaXMgY2FzZSkuXG5cblxuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoaW50ZXJ2YWwpOyAvLyBJdCdzIHJlYWxseSBpbXBvcnRhbnQgdGhhdCBjaGVja0NhbGxiYWNrIGlzIHJ1biAqYmVmb3JlKiB3ZSBmbHVzaFxuICAgICAgICAvLyBpbi1mbGlnaHQgcHJvbWlzZXMuIFRvIGJlIGhvbmVzdCwgSSdtIG5vdCBzdXJlIHdoeSwgYW5kIEkgY2FuJ3QgcXVpdGVcbiAgICAgICAgLy8gdGhpbmsgb2YgYSB3YXkgdG8gcmVwcm9kdWNlIHRoZSBwcm9ibGVtIGluIGEgdGVzdCwgYnV0IEkgc3BlbnRcbiAgICAgICAgLy8gYW4gZW50aXJlIGRheSBiYW5naW5nIG15IGhlYWQgYWdhaW5zdCBhIHdhbGwgb24gdGhpcy5cblxuICAgICAgICBjaGVja0NhbGxiYWNrKCk7IC8vIEluIHRoaXMgcmFyZSBjYXNlLCB3ZSAqbmVlZCogdG8gd2FpdCBmb3IgaW4tZmxpZ2h0IHByb21pc2VzXG4gICAgICAgIC8vIHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuIFdlIGRvbid0IG5lZWQgdG8gdGFrZSBhZHZhbnRhZ2VcbiAgICAgICAgLy8gb2YgcGFyYWxsZWxpemF0aW9uIHNvIHdlJ3JlIGZpbmUuXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81OTI0MzU4Ni85NzE1OTJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KHIsIDApO1xuICAgICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICgwLCBfaGVscGVycy5jaGVja0NvbnRhaW5lclR5cGUpKGNvbnRhaW5lcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2ssIGludGVydmFsKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgTXV0YXRpb25PYnNlcnZlclxuICAgICAgfSA9ICgwLCBfaGVscGVycy5nZXRXaW5kb3dGcm9tTm9kZSkoY29udGFpbmVyKTtcbiAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2hlY2tSZWFsVGltZXJzQ2FsbGJhY2spO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIsIG11dGF0aW9uT2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGNoZWNrQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRvbmUoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KG92ZXJhbGxUaW1lb3V0VGltZXIpO1xuXG4gICAgICBpZiAoIXVzaW5nSmVzdEZha2VUaW1lcnMpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1JlYWxUaW1lcnNDYWxsYmFjaygpIHtcbiAgICAgIGlmICgoMCwgX2hlbHBlcnMuamVzdEZha2VUaW1lcnNBcmVFbmFibGVkKSgpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBDaGFuZ2VkIGZyb20gdXNpbmcgcmVhbCB0aW1lcnMgdG8gZmFrZSB0aW1lcnMgd2hpbGUgdXNpbmcgd2FpdEZvci4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgd2lsbCByZXN1bHQgaW4gdmVyeSBzdHJhbmdlIGJlaGF2aW9yLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBhd2FpdGluZyBhbGwgYXN5bmMgdGhpbmdzIHlvdXIgdGVzdCBpcyBkb2luZyBiZWZvcmUgY2hhbmdpbmcgdG8gZmFrZSB0aW1lcnMuIEZvciBtb3JlIGluZm8sIHBsZWFzZSBnbyB0byBodHRwczovL2dpdGh1Yi5jb20vdGVzdGluZy1saWJyYXJ5L2RvbS10ZXN0aW5nLWxpYnJhcnkvaXNzdWVzLzgzMGApO1xuICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UpIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGVja0NhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tDYWxsYmFjaygpIHtcbiAgICAgIGlmIChwcm9taXNlU3RhdHVzID09PSAncGVuZGluZycpIHJldHVybjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9jb25maWcucnVuV2l0aEV4cGVuc2l2ZUVycm9yRGlhZ25vc3RpY3NEaXNhYmxlZCkoY2FsbGJhY2spO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcmVzdWx0LnRoZW4pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcHJvbWlzZVN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgICByZXN1bHQudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgICAgIHByb21pc2VTdGF0dXMgPSAncmVzb2x2ZWQnO1xuICAgICAgICAgICAgb25Eb25lKG51bGwsIHJlc29sdmVkVmFsdWUpO1xuICAgICAgICAgIH0sIHJlamVjdGVkVmFsdWUgPT4ge1xuICAgICAgICAgICAgcHJvbWlzZVN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSByZWplY3RlZFZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uRG9uZShudWxsLCByZXN1bHQpO1xuICAgICAgICB9IC8vIElmIGBjYWxsYmFja2AgdGhyb3dzLCB3YWl0IGZvciB0aGUgbmV4dCBtdXRhdGlvbiwgaW50ZXJ2YWwsIG9yIHRpbWVvdXQuXG5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFNhdmUgdGhlIG1vc3QgcmVjZW50IGNhbGxiYWNrIGVycm9yIHRvIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIGl0IGluIHRoZSBldmVudCBvZiBhIHRpbWVvdXRcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIGxldCBlcnJvcjtcblxuICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICBlcnJvciA9IGxhc3RFcnJvcjtcblxuICAgICAgICBpZiAoIXNob3dPcmlnaW5hbFN0YWNrVHJhY2UgJiYgZXJyb3IubmFtZSA9PT0gJ1Rlc3RpbmdMaWJyYXJ5RWxlbWVudEVycm9yJykge1xuICAgICAgICAgIGNvcHlTdGFja1RyYWNlKGVycm9yLCBzdGFja1RyYWNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignVGltZWQgb3V0IGluIHdhaXRGb3IuJyk7XG5cbiAgICAgICAgaWYgKCFzaG93T3JpZ2luYWxTdGFja1RyYWNlKSB7XG4gICAgICAgICAgY29weVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrVHJhY2VFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb25Eb25lKG9uVGltZW91dChlcnJvciksIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JXcmFwcGVyKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZSB0aGUgZXJyb3IgaGVyZSBzbyBpdHMgc3RhY2sgdHJhY2UgaXMgYXMgY2xvc2UgdG8gdGhlXG4gIC8vIGNhbGxpbmcgY29kZSBhcyBwb3NzaWJsZVxuICBjb25zdCBzdGFja1RyYWNlRXJyb3IgPSBuZXcgRXJyb3IoJ1NUQUNLX1RSQUNFX01FU1NBR0UnKTtcbiAgcmV0dXJuICgwLCBfY29uZmlnLmdldENvbmZpZykoKS5hc3luY1dyYXBwZXIoKCkgPT4gd2FpdEZvcihjYWxsYmFjaywge1xuICAgIHN0YWNrVHJhY2VFcnJvcixcbiAgICAuLi5vcHRpb25zXG4gIH0pKTtcbn1cbi8qXG5lc2xpbnRcbiAgbWF4LWxpbmVzLXBlci1mdW5jdGlvbjogW1wiZXJyb3JcIiwge1wibWF4XCI6IDIwMH1dLFxuKi8iXX0=