{"version":3,"sources":["mathMod.js"],"names":["_curry2","require","_isInteger","mathMod","m","p","NaN","module","exports"],"mappings":"AAAA,IAAIA,OAAO,GAAgBC,OAAO,sBAAlC;;AAEA,IAAIC,UAAU,GAAgBD,OAAO,yBAArC;;AAqCA,IAAIE,OAAO,GAAgBH,OAAO,CAAC,SAASG,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACxD,MAAI,CAACH,UAAU,CAACE,CAAD,CAAf,EAAoB;AAClB,WAAOE,GAAP;AACD;;AACD,MAAI,CAACJ,UAAU,CAACG,CAAD,CAAX,IAAkBA,CAAC,GAAG,CAA1B,EAA6B;AAC3B,WAAOC,GAAP;AACD;;AACD,SAAO,CAACF,CAAC,GAAGC,CAAJ,GAAQA,CAAT,IAAcA,CAArB;AACD,CARiC,CAAlC;;AASAE,MAAM,CAACC,OAAP,GAAiBL,OAAjB","sourcesContent":["var _curry2 = /*#__PURE__*/require('./internal/_curry2');\n\nvar _isInteger = /*#__PURE__*/require('./internal/_isInteger');\n\n/**\n * `mathMod` behaves like the modulo operator should mathematically, unlike the\n * `%` operator (and by extension, [`R.modulo`](#modulo)). So while\n * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer\n * arguments, and returns NaN when the modulus is zero or negative.\n *\n * @func\n * @memberOf R\n * @since v0.3.0\n * @category Math\n * @sig Number -> Number -> Number\n * @param {Number} m The dividend.\n * @param {Number} p the modulus.\n * @return {Number} The result of `b mod a`.\n * @see R.modulo\n * @example\n *\n *      R.mathMod(-17, 5);  //=> 3\n *      R.mathMod(17, 5);   //=> 2\n *      R.mathMod(17, -5);  //=> NaN\n *      R.mathMod(17, 0);   //=> NaN\n *      R.mathMod(17.2, 5); //=> NaN\n *      R.mathMod(17, 5.3); //=> NaN\n *\n *      const clock = R.mathMod(R.__, 12);\n *      clock(15); //=> 3\n *      clock(24); //=> 0\n *\n *      const seventeenMod = R.mathMod(17);\n *      seventeenMod(3);  //=> 2\n *      seventeenMod(4);  //=> 1\n *      seventeenMod(10); //=> 7\n */\n\n\nvar mathMod = /*#__PURE__*/_curry2(function mathMod(m, p) {\n  if (!_isInteger(m)) {\n    return NaN;\n  }\n  if (!_isInteger(p) || p < 1) {\n    return NaN;\n  }\n  return (m % p + p) % p;\n});\nmodule.exports = mathMod;"]}