{"version":3,"sources":["playback_interceptor.js"],"names":["stream","require","util","zlib","debug","common","parseJSONRequestBody","req","requestBody","isJSONContent","headers","contentEncoding","String","gunzipSync","Buffer","from","inflateSync","JSON","parse","parseFullReplyResult","response","fullReplyResult","Array","isArray","Error","length","status","body","Number","isInteger","statusCode","rawHeaders","push","headersInputToRawArray","selectDefaultHeaders","existingHeaders","defaultHeaders","definedHeaders","Set","result","forEachHeader","_","fieldName","add","toLowerCase","value","has","ReadableBuffers","buffers","opts","size","shift","Readable","convertBodyToStream","isStream","undefined","isBuffer","stringify","playbackInterceptor","socket","options","requestBodyString","requestBodyIsUtf8Representable","interceptor","logger","scope","start","getHeaders","emit","errorMessage","error","delay","delayBodyInMs","delayConnectionInMs","setTimeout","destroy","replyFunction","parsedRequestBody","fn","promisify","Promise","resolve","call","path","then","continueWithResponseBody","catch","err","fullReplyFunction","continueWithFullResponse","isContentEncoded","bufferData","responseBuffers","map","data","responseBody","prepareResponseHeaders","_defaultReplyHeaders","isJSON","i","headersArrayToObject","rawBody","bodyAsStream","pause","on","chunk","complete","respond","isRequestDestroyed","res","resume","applyDelay","setImmediate","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst zlib = require('zlib')\nconst debug = require('debug')('nock.playback_interceptor')\nconst common = require('./common')\n\nfunction parseJSONRequestBody(req, requestBody) {\n  if (!requestBody || !common.isJSONContent(req.headers)) {\n    return requestBody\n  }\n\n  if (common.contentEncoding(req.headers, 'gzip')) {\n    requestBody = String(zlib.gunzipSync(Buffer.from(requestBody, 'hex')))\n  } else if (common.contentEncoding(req.headers, 'deflate')) {\n    requestBody = String(zlib.inflateSync(Buffer.from(requestBody, 'hex')))\n  }\n\n  return JSON.parse(requestBody)\n}\n\nfunction parseFullReplyResult(response, fullReplyResult) {\n  debug('full response from callback result: %j', fullReplyResult)\n\n  if (!Array.isArray(fullReplyResult)) {\n    throw Error('A single function provided to .reply MUST return an array')\n  }\n\n  if (fullReplyResult.length > 3) {\n    throw Error(\n      'The array returned from the .reply callback contains too many values'\n    )\n  }\n\n  const [status, body = '', headers] = fullReplyResult\n\n  if (!Number.isInteger(status)) {\n    throw new Error(`Invalid ${typeof status} value for status code`)\n  }\n\n  response.statusCode = status\n  response.rawHeaders.push(...common.headersInputToRawArray(headers))\n  debug('response.rawHeaders after reply: %j', response.rawHeaders)\n\n  return body\n}\n\n/**\n * Determine which of the default headers should be added to the response.\n *\n * Don't include any defaults whose case-insensitive keys are already on the response.\n */\nfunction selectDefaultHeaders(existingHeaders, defaultHeaders) {\n  if (!defaultHeaders.length) {\n    return [] // return early if we don't need to bother\n  }\n\n  const definedHeaders = new Set()\n  const result = []\n\n  common.forEachHeader(existingHeaders, (_, fieldName) => {\n    definedHeaders.add(fieldName.toLowerCase())\n  })\n  common.forEachHeader(defaultHeaders, (value, fieldName) => {\n    if (!definedHeaders.has(fieldName.toLowerCase())) {\n      result.push(fieldName, value)\n    }\n  })\n\n  return result\n}\n\n// Presents a list of Buffers as a Readable\nclass ReadableBuffers extends stream.Readable {\n  constructor(buffers, opts = {}) {\n    super(opts)\n\n    this.buffers = buffers\n  }\n\n  _read(size) {\n    while (this.buffers.length) {\n      if (!this.push(this.buffers.shift())) {\n        return\n      }\n    }\n    this.push(null)\n  }\n}\n\nfunction convertBodyToStream(body) {\n  if (common.isStream(body)) {\n    return body\n  }\n\n  if (body === undefined) {\n    return new ReadableBuffers([])\n  }\n\n  if (Buffer.isBuffer(body)) {\n    return new ReadableBuffers([body])\n  }\n\n  if (typeof body !== 'string') {\n    body = JSON.stringify(body)\n  }\n\n  return new ReadableBuffers([Buffer.from(body)])\n}\n\n/**\n * Play back an interceptor using the given request and mock response.\n */\nfunction playbackInterceptor({\n  req,\n  socket,\n  options,\n  requestBodyString,\n  requestBodyIsUtf8Representable,\n  response,\n  interceptor,\n}) {\n  const { logger } = interceptor.scope\n\n  function start() {\n    req.headers = req.getHeaders()\n\n    interceptor.scope.emit('request', req, interceptor, requestBodyString)\n\n    if (typeof interceptor.errorMessage !== 'undefined') {\n      let error\n      if (typeof interceptor.errorMessage === 'object') {\n        error = interceptor.errorMessage\n      } else {\n        error = new Error(interceptor.errorMessage)\n      }\n\n      const delay = interceptor.delayBodyInMs + interceptor.delayConnectionInMs\n      common.setTimeout(() => req.destroy(error), delay)\n      return\n    }\n\n    // This will be null if we have a fullReplyFunction,\n    // in that case status code will be set in `parseFullReplyResult`\n    response.statusCode = interceptor.statusCode\n\n    // Clone headers/rawHeaders to not override them when evaluating later\n    response.rawHeaders = [...interceptor.rawHeaders]\n    logger('response.rawHeaders:', response.rawHeaders)\n\n    // TODO: MAJOR: Don't tack the request onto the interceptor.\n    // The only reason we do this is so that it's available inside reply functions.\n    // It would be better to pass the request as an argument to the functions instead.\n    // Not adding the req as a third arg now because it should first be decided if (path, body, req)\n    // is the signature we want to go with going forward.\n    interceptor.req = req\n\n    if (interceptor.replyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.replyFunction\n      if (fn.length === 3) {\n        // Handle the case of an async reply function, the third parameter being the callback.\n        fn = util.promisify(fn)\n      }\n\n      // At this point `fn` is either a synchronous function or a promise-returning function;\n      // wrapping in `Promise.resolve` makes it into a promise either way.\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithResponseBody)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (interceptor.fullReplyFunction) {\n      const parsedRequestBody = parseJSONRequestBody(req, requestBodyString)\n\n      let fn = interceptor.fullReplyFunction\n      if (fn.length === 3) {\n        fn = util.promisify(fn)\n      }\n\n      Promise.resolve(fn.call(interceptor, options.path, parsedRequestBody))\n        .then(continueWithFullResponse)\n        .catch(err => req.destroy(err))\n      return\n    }\n\n    if (\n      common.isContentEncoded(interceptor.headers) &&\n      !common.isStream(interceptor.body)\n    ) {\n      //  If the content is encoded we know that the response body *must* be an array\n      //  of response buffers which should be mocked one by one.\n      //  (otherwise decompressions after the first one fails as unzip expects to receive\n      //  buffer by buffer and not one single merged buffer)\n      const bufferData = Array.isArray(interceptor.body)\n        ? interceptor.body\n        : [interceptor.body]\n      const responseBuffers = bufferData.map(data => Buffer.from(data, 'hex'))\n      const responseBody = new ReadableBuffers(responseBuffers)\n      continueWithResponseBody(responseBody)\n      return\n    }\n\n    // If we get to this point, the body is either a string or an object that\n    // will eventually be JSON stringified.\n    let responseBody = interceptor.body\n\n    // If the request was not UTF8-representable then we assume that the\n    // response won't be either. In that case we send the response as a Buffer\n    // object as that's what the client will expect.\n    if (!requestBodyIsUtf8Representable && typeof responseBody === 'string') {\n      // Try to create the buffer from the interceptor's body response as hex.\n      responseBody = Buffer.from(responseBody, 'hex')\n\n      // Creating buffers does not necessarily throw errors; check for difference in size.\n      if (\n        !responseBody ||\n        (interceptor.body.length > 0 && responseBody.length === 0)\n      ) {\n        // We fallback on constructing buffer from utf8 representation of the body.\n        responseBody = Buffer.from(interceptor.body, 'utf8')\n      }\n    }\n\n    return continueWithResponseBody(responseBody)\n  }\n\n  function continueWithFullResponse(fullReplyResult) {\n    let responseBody\n    try {\n      responseBody = parseFullReplyResult(response, fullReplyResult)\n    } catch (err) {\n      req.destroy(err)\n      return\n    }\n\n    continueWithResponseBody(responseBody)\n  }\n\n  function prepareResponseHeaders(body) {\n    const defaultHeaders = [...interceptor.scope._defaultReplyHeaders]\n\n    // Include a JSON content type when JSON.stringify is called on the body.\n    // This is a convenience added by Nock that has no analog in Node. It's added to the\n    // defaults, so it will be ignored if the caller explicitly provided the header already.\n    const isJSON =\n      body !== undefined &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body)\n\n    if (isJSON) {\n      defaultHeaders.push('Content-Type', 'application/json')\n    }\n\n    response.rawHeaders.push(\n      ...selectDefaultHeaders(response.rawHeaders, defaultHeaders)\n    )\n\n    // Evaluate functional headers.\n    common.forEachHeader(response.rawHeaders, (value, fieldName, i) => {\n      if (typeof value === 'function') {\n        response.rawHeaders[i + 1] = value(req, response, body)\n      }\n    })\n\n    response.headers = common.headersArrayToObject(response.rawHeaders)\n  }\n\n  function continueWithResponseBody(rawBody) {\n    prepareResponseHeaders(rawBody)\n    const bodyAsStream = convertBodyToStream(rawBody)\n    bodyAsStream.pause()\n\n    // IncomingMessage extends Readable so we can't simply pipe.\n    bodyAsStream.on('data', function (chunk) {\n      response.push(chunk)\n    })\n    bodyAsStream.on('end', function () {\n      // https://nodejs.org/dist/latest-v10.x/docs/api/http.html#http_message_complete\n      response.complete = true\n      response.push(null)\n\n      interceptor.scope.emit('replied', req, interceptor)\n    })\n    bodyAsStream.on('error', function (err) {\n      response.emit('error', err)\n    })\n\n    const { delayBodyInMs, delayConnectionInMs } = interceptor\n\n    function respond() {\n      if (common.isRequestDestroyed(req)) {\n        return\n      }\n\n      // Even though we've had the response object for awhile at this point,\n      // we only attach it to the request immediately before the `response`\n      // event because, as in Node, it alters the error handling around aborts.\n      req.res = response\n      response.req = req\n\n      logger('emitting response')\n      req.emit('response', response)\n\n      common.setTimeout(() => bodyAsStream.resume(), delayBodyInMs)\n    }\n\n    socket.applyDelay(delayConnectionInMs)\n    common.setTimeout(respond, delayConnectionInMs)\n  }\n\n  // Calling `start` immediately could take the request all the way to the connection delay\n  // during a single microtask execution. This setImmediate stalls the playback to ensure the\n  // correct events are emitted first ('socket', 'finish') and any aborts in the in the queue or\n  // called during a 'finish' listener can be called.\n  common.setImmediate(() => {\n    if (!common.isRequestDestroyed(req)) {\n      start()\n    }\n  })\n}\n\nmodule.exports = { playbackInterceptor }\n"]}