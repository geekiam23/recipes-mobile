{"version":3,"sources":["interceptor.js"],"names":["stringify","require","querystring","URL","URLSearchParams","common","remove","matchBody","fs","err","module","exports","scope","uri","method","requestBody","interceptorOptions","uriIsStr","scopeOptions","filteringScope","basePathname","startsWith","Error","interceptorMatchHeaders","toUpperCase","_key","basePath","path","queries","options","counter","_requestBody","reqheaders","headersFieldNamesToLowerCase","badheaders","headersFieldsArrayToLowerCase","delayBodyInMs","delayConnectionInMs","optional","includes","parsedURL","pathname","query","searchParams","flag","errorMessage","add","statusCode","body","rawHeaders","arguments","length","fullReplyFunction","undefined","Number","isInteger","replyFunction","headersInputToRawArray","date","push","toUTCString","headers","headersArrayToObject","concat","_defaultReplyHeaders","Buffer","isBuffer","isStream","isContentEncoded","contentLen","logger","filePath","readStream","createReadStream","pause","reply","key","reqHeader","header","toString","matchStringOrRegexp","req","enabled","matches","matchKey","proto","transformPathFunction","requestMatchesFilter","name","predicate","value","headerValue","getHeader","matchHeaders","every","reqHeadersMatch","Object","keys","reqheaderMatches","conditionally","badHeaders","filter","split","search","matchQueries","matchQuery","__nock_filteredScope","normalizeOrigin","host","port","call","transformRequestBodyFunction","isPathFn","isRegex","RegExp","isRegexBasePath","comparisonKey","__nock_scopeKey","match","test","hostname","urlParts","reqQueries","parse","dataEqual","filteringPath","interceptionCounter","shouldPersist","user","pass","encoded","from","matchHeader","strFormattingFn","encodedQueryParams","percentDecode","isPlainObject","entries","formatted","formatQueryValue","formattedKey","formattedValue","newCounter","times","opts","headDelay","bodyDelay","head","delayConnection","delayBody","ms"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stringify = require('json-stringify-safe')\nconst querystring = require('querystring')\nconst { URL, URLSearchParams } = require('url')\n\nconst common = require('./common')\nconst { remove } = require('./intercept')\nconst matchBody = require('./match_body')\n\nlet fs\ntry {\n  fs = require('fs')\n} catch (err) {\n  // do nothing, we're in the browser\n}\n\nmodule.exports = class Interceptor {\n  /**\n   *\n   * Valid argument types for `uri`:\n   *  - A string used for strict comparisons with pathname.\n   *    The search portion of the URI may also be postfixed, in which case the search params\n   *    are striped and added via the `query` method.\n   *  - A RegExp instance that tests against only the pathname of requests.\n   *  - A synchronous function bound to this Interceptor instance. It's provided the pathname\n   *    of requests and must return a boolean denoting if the request is considered a match.\n   */\n  constructor(scope, uri, method, requestBody, interceptorOptions) {\n    const uriIsStr = typeof uri === 'string'\n    // Check for leading slash. Uri can be either a string or a regexp, but\n    // When enabled filteringScope ignores the passed URL entirely so we skip validation.\n\n    if (\n      uriIsStr &&\n      !scope.scopeOptions.filteringScope &&\n      !scope.basePathname &&\n      !uri.startsWith('/') &&\n      !uri.startsWith('*')\n    ) {\n      throw Error(\n        `Non-wildcard URL path strings must begin with a slash (otherwise they won't match anything) (got: ${uri})`\n      )\n    }\n\n    if (!method) {\n      throw new Error(\n        'The \"method\" parameter is required for an intercept call.'\n      )\n    }\n\n    this.scope = scope\n    this.interceptorMatchHeaders = []\n    this.method = method.toUpperCase()\n    this.uri = uri\n    this._key = `${this.method} ${scope.basePath}${scope.basePathname}${\n      uriIsStr ? '' : '/'\n    }${uri}`\n    this.basePath = this.scope.basePath\n    this.path = uriIsStr ? scope.basePathname + uri : uri\n    this.queries = null\n\n    this.options = interceptorOptions || {}\n    this.counter = 1\n    this._requestBody = requestBody\n\n    //  We use lower-case header field names throughout Nock.\n    this.reqheaders = common.headersFieldNamesToLowerCase(\n      scope.scopeOptions.reqheaders || {}\n    )\n    this.badheaders = common.headersFieldsArrayToLowerCase(\n      scope.scopeOptions.badheaders || []\n    )\n\n    this.delayBodyInMs = 0\n    this.delayConnectionInMs = 0\n\n    this.optional = false\n\n    // strip off literal query parameters if they were provided as part of the URI\n    if (uriIsStr && uri.includes('?')) {\n      // localhost is a dummy value because the URL constructor errors for only relative inputs\n      const parsedURL = new URL(this.path, 'http://localhost')\n      this.path = parsedURL.pathname\n      this.query(parsedURL.searchParams)\n      this._key = `${this.method} ${scope.basePath}${this.path}`\n    }\n  }\n\n  optionally(flag = true) {\n    // The default behaviour of optionally() with no arguments is to make the mock optional.\n    if (typeof flag !== 'boolean') {\n      throw new Error('Invalid arguments: argument should be a boolean')\n    }\n\n    this.optional = flag\n\n    return this\n  }\n\n  replyWithError(errorMessage) {\n    this.errorMessage = errorMessage\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  reply(statusCode, body, rawHeaders) {\n    // support the format of only passing in a callback\n    if (typeof statusCode === 'function') {\n      if (arguments.length > 1) {\n        // It's not very Javascript-y to throw an error for extra args to a function, but because\n        // of legacy behavior, this error was added to reduce confusion for those migrating.\n        throw Error(\n          'Invalid arguments. When providing a function for the first argument, .reply does not accept other arguments.'\n        )\n      }\n      this.statusCode = null\n      this.fullReplyFunction = statusCode\n    } else {\n      if (statusCode !== undefined && !Number.isInteger(statusCode)) {\n        throw new Error(`Invalid ${typeof statusCode} value for status code`)\n      }\n\n      this.statusCode = statusCode || 200\n      if (typeof body === 'function') {\n        this.replyFunction = body\n        body = null\n      }\n    }\n\n    this.options = {\n      ...this.scope.scopeOptions,\n      ...this.options,\n    }\n\n    this.rawHeaders = common.headersInputToRawArray(rawHeaders)\n\n    if (this.scope.date) {\n      // https://tools.ietf.org/html/rfc7231#section-7.1.1.2\n      this.rawHeaders.push('Date', this.scope.date.toUTCString())\n    }\n\n    // Prepare the headers temporarily so we can make best guesses about content-encoding and content-type\n    // below as well as while the response is being processed in RequestOverrider.end().\n    // Including all the default headers is safe for our purposes because of the specific headers we introspect.\n    // A more thoughtful process is used to merge the default headers when the response headers are finally computed.\n    this.headers = common.headersArrayToObject(\n      this.rawHeaders.concat(this.scope._defaultReplyHeaders)\n    )\n\n    //  If the content is not encoded we may need to transform the response body.\n    //  Otherwise we leave it as it is.\n    if (\n      body &&\n      typeof body !== 'string' &&\n      !Buffer.isBuffer(body) &&\n      !common.isStream(body) &&\n      !common.isContentEncoded(this.headers)\n    ) {\n      try {\n        body = stringify(body)\n      } catch (err) {\n        throw new Error('Error encoding response body into JSON')\n      }\n\n      if (!this.headers['content-type']) {\n        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n        this.rawHeaders.push('Content-Type', 'application/json')\n      }\n\n      if (this.scope.contentLen) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        this.rawHeaders.push('Content-Length', body.length)\n      }\n    }\n\n    this.scope.logger('reply.headers:', this.headers)\n    this.scope.logger('reply.rawHeaders:', this.rawHeaders)\n\n    this.body = body\n\n    this.scope.add(this._key, this)\n    return this.scope\n  }\n\n  replyWithFile(statusCode, filePath, headers) {\n    if (!fs) {\n      throw new Error('No fs')\n    }\n    const readStream = fs.createReadStream(filePath)\n    readStream.pause()\n    this.filePath = filePath\n    return this.reply(statusCode, readStream, headers)\n  }\n\n  // Also match request headers\n  // https://github.com/nock/nock/issues/163\n  reqheaderMatches(options, key) {\n    const reqHeader = this.reqheaders[key]\n    let header = options.headers[key]\n\n    // https://github.com/nock/nock/issues/399\n    // https://github.com/nock/nock/issues/822\n    if (header && typeof header !== 'string' && header.toString) {\n      header = header.toString()\n    }\n\n    // We skip 'host' header comparison unless it's available in both mock and\n    // actual request. This because 'host' may get inserted by Nock itself and\n    // then get recorded. NOTE: We use lower-case header field names throughout\n    // Nock. See https://github.com/nock/nock/pull/196.\n    if (key === 'host' && (header === undefined || reqHeader === undefined)) {\n      return true\n    }\n\n    if (reqHeader !== undefined && header !== undefined) {\n      if (typeof reqHeader === 'function') {\n        return reqHeader(header)\n      } else if (common.matchStringOrRegexp(header, reqHeader)) {\n        return true\n      }\n    }\n\n    this.scope.logger(\n      \"request header field doesn't match:\",\n      key,\n      header,\n      reqHeader\n    )\n    return false\n  }\n\n  match(req, options, body) {\n    // check if the logger is enabled because the stringifies can be expensive.\n    if (this.scope.logger.enabled) {\n      this.scope.logger(\n        'attempting match %s, body = %s',\n        stringify(options),\n        stringify(body)\n      )\n    }\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path = '/' } = options\n    let matches\n    let matchKey\n    const { proto } = options\n\n    if (this.method !== method) {\n      this.scope.logger(\n        `Method did not match. Request ${method} Interceptor ${this.method}`\n      )\n      return false\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n\n    const requestMatchesFilter = ({ name, value: predicate }) => {\n      const headerValue = req.getHeader(name)\n      if (typeof predicate === 'function') {\n        return predicate(headerValue)\n      } else {\n        return common.matchStringOrRegexp(headerValue, predicate)\n      }\n    }\n\n    if (\n      !this.scope.matchHeaders.every(requestMatchesFilter) ||\n      !this.interceptorMatchHeaders.every(requestMatchesFilter)\n    ) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    const reqHeadersMatch = Object.keys(this.reqheaders).every(key =>\n      this.reqheaderMatches(options, key)\n    )\n\n    if (!reqHeadersMatch) {\n      this.scope.logger(\"headers don't match\")\n      return false\n    }\n\n    if (\n      this.scope.scopeOptions.conditionally &&\n      !this.scope.scopeOptions.conditionally()\n    ) {\n      this.scope.logger(\n        'matching failed because Scope.conditionally() did not validate'\n      )\n      return false\n    }\n\n    const badHeaders = this.badheaders.filter(\n      header => header in options.headers\n    )\n\n    if (badHeaders.length) {\n      this.scope.logger('request contains bad headers', ...badHeaders)\n      return false\n    }\n\n    // Match query strings when using query()\n    if (this.queries === null) {\n      this.scope.logger('query matching skipped')\n    } else {\n      // can't rely on pathname or search being in the options, but path has a default\n      const [pathname, search] = path.split('?')\n      const matchQueries = this.matchQuery({ search })\n\n      this.scope.logger(\n        matchQueries ? 'query matching succeeded' : 'query matching failed'\n      )\n\n      if (!matchQueries) {\n        return false\n      }\n\n      // If the query string was explicitly checked then subsequent checks against\n      // the path using a callback or regexp only validate the pathname.\n      path = pathname\n    }\n\n    // If we have a filtered scope then we use it instead reconstructing the\n    // scope from the request options (proto, host and port) as these two won't\n    // necessarily match and we have to remove the scope that was matched (vs.\n    // that was defined).\n    if (this.__nock_filteredScope) {\n      matchKey = this.__nock_filteredScope\n    } else {\n      matchKey = common.normalizeOrigin(proto, options.host, options.port)\n    }\n\n    if (typeof this.uri === 'function') {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        // This is a false positive, as `uri` is not bound to `this`.\n        // eslint-disable-next-line no-useless-call\n        this.uri.call(this, path)\n    } else {\n      matches =\n        common.matchStringOrRegexp(matchKey, this.basePath) &&\n        common.matchStringOrRegexp(path, this.path)\n    }\n\n    this.scope.logger(`matching ${matchKey}${path} to ${this._key}: ${matches}`)\n\n    if (matches && this._requestBody !== undefined) {\n      if (this.scope.transformRequestBodyFunction) {\n        body = this.scope.transformRequestBodyFunction(body, this._requestBody)\n      }\n\n      matches = matchBody(options, this._requestBody, body)\n      if (!matches) {\n        this.scope.logger(\n          \"bodies don't match: \\n\",\n          this._requestBody,\n          '\\n',\n          body\n        )\n      }\n    }\n\n    return matches\n  }\n\n  /**\n   * Return true when the interceptor's method, protocol, host, port, and path\n   * match the provided options.\n   */\n  matchOrigin(options) {\n    const isPathFn = typeof this.path === 'function'\n    const isRegex = this.path instanceof RegExp\n    const isRegexBasePath = this.scope.basePath instanceof RegExp\n\n    const method = (options.method || 'GET').toUpperCase()\n    let { path } = options\n    const { proto } = options\n\n    // NOTE: Do not split off the query params as the regex could use them\n    if (!isRegex) {\n      path = path ? path.split('?')[0] : ''\n    }\n\n    if (this.scope.transformPathFunction) {\n      path = this.scope.transformPathFunction(path)\n    }\n    const comparisonKey = isPathFn || isRegex ? this.__nock_scopeKey : this._key\n    const matchKey = `${method} ${proto}://${options.host}${path}`\n\n    if (isPathFn) {\n      return !!(matchKey.match(comparisonKey) && this.path(path))\n    }\n\n    if (isRegex && !isRegexBasePath) {\n      return !!matchKey.match(comparisonKey) && this.path.test(path)\n    }\n\n    if (isRegexBasePath) {\n      return this.scope.basePath.test(matchKey) && !!path.match(this.path)\n    }\n\n    return comparisonKey === matchKey\n  }\n\n  matchHostName(options) {\n    return options.hostname === this.scope.urlParts.hostname\n  }\n\n  matchQuery(options) {\n    if (this.queries === true) {\n      return true\n    }\n\n    const reqQueries = querystring.parse(options.search)\n    this.scope.logger('Interceptor queries: %j', this.queries)\n    this.scope.logger('    Request queries: %j', reqQueries)\n\n    if (typeof this.queries === 'function') {\n      return this.queries(reqQueries)\n    }\n\n    return common.dataEqual(this.queries, reqQueries)\n  }\n\n  filteringPath(...args) {\n    this.scope.filteringPath(...args)\n    return this\n  }\n\n  // TODO filtering by path is valid on the intercept level, but not filtering\n  // by request body?\n\n  markConsumed() {\n    this.interceptionCounter++\n\n    remove(this)\n\n    if ((this.scope.shouldPersist() || this.counter > 0) && this.filePath) {\n      this.body = fs.createReadStream(this.filePath)\n      this.body.pause()\n    }\n\n    if (!this.scope.shouldPersist() && this.counter < 1) {\n      this.scope.remove(this._key, this)\n    }\n  }\n\n  matchHeader(name, value) {\n    this.interceptorMatchHeaders.push({ name, value })\n    return this\n  }\n\n  basicAuth({ user, pass = '' }) {\n    const encoded = Buffer.from(`${user}:${pass}`).toString('base64')\n    this.matchHeader('authorization', `Basic ${encoded}`)\n    return this\n  }\n\n  /**\n   * Set query strings for the interceptor\n   * @name query\n   * @param queries Object of query string name,values (accepts regexp values)\n   * @public\n   * @example\n   * // Will match 'http://zombo.com/?q=t'\n   * nock('http://zombo.com').get('/').query({q: 't'});\n   */\n  query(queries) {\n    if (this.queries !== null) {\n      throw Error(`Query parameters have already been defined`)\n    }\n\n    // Allow all query strings to match this route\n    if (queries === true) {\n      this.queries = queries\n      return this\n    }\n\n    if (typeof queries === 'function') {\n      this.queries = queries\n      return this\n    }\n\n    let strFormattingFn\n    if (this.scope.scopeOptions.encodedQueryParams) {\n      strFormattingFn = common.percentDecode\n    }\n\n    if (queries instanceof URLSearchParams) {\n      // Normalize the data into the shape that is matched against.\n      // Duplicate keys are handled by combining the values into an array.\n      queries = querystring.parse(queries.toString())\n    } else if (!common.isPlainObject(queries)) {\n      throw Error(`Argument Error: ${queries}`)\n    }\n\n    this.queries = {}\n    for (const [key, value] of Object.entries(queries)) {\n      const formatted = common.formatQueryValue(key, value, strFormattingFn)\n      const [formattedKey, formattedValue] = formatted\n      this.queries[formattedKey] = formattedValue\n    }\n\n    return this\n  }\n\n  /**\n   * Set number of times will repeat the interceptor\n   * @name times\n   * @param newCounter Number of times to repeat (should be > 0)\n   * @public\n   * @example\n   * // Will repeat mock 5 times for same king of request\n   * nock('http://zombo.com).get('/').times(5).reply(200, 'Ok');\n   */\n  times(newCounter) {\n    if (newCounter < 1) {\n      return this\n    }\n\n    this.counter = newCounter\n\n    return this\n  }\n\n  /**\n   * An sugar syntax for times(1)\n   * @name once\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').once().reply(200, 'Ok');\n   */\n  once() {\n    return this.times(1)\n  }\n\n  /**\n   * An sugar syntax for times(2)\n   * @name twice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').twice().reply(200, 'Ok');\n   */\n  twice() {\n    return this.times(2)\n  }\n\n  /**\n   * An sugar syntax for times(3).\n   * @name thrice\n   * @see {@link times}\n   * @public\n   * @example\n   * nock('http://zombo.com).get('/').thrice().reply(200, 'Ok');\n   */\n  thrice() {\n    return this.times(3)\n  }\n\n  /**\n   * Delay the response by a certain number of ms.\n   *\n   * @param {(integer|object)} opts - Number of milliseconds to wait, or an object\n   * @param {integer} [opts.head] - Number of milliseconds to wait before response is sent\n   * @param {integer} [opts.body] - Number of milliseconds to wait before response body is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delay(opts) {\n    let headDelay\n    let bodyDelay\n    if (typeof opts === 'number') {\n      headDelay = opts\n      bodyDelay = 0\n    } else if (typeof opts === 'object') {\n      headDelay = opts.head || 0\n      bodyDelay = opts.body || 0\n    } else {\n      throw new Error(`Unexpected input opts ${opts}`)\n    }\n\n    return this.delayConnection(headDelay).delayBody(bodyDelay)\n  }\n\n  /**\n   * Delay the response body by a certain number of ms.\n   *\n   * @param {integer} ms - Number of milliseconds to wait before response is sent\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayBody(ms) {\n    this.delayBodyInMs = ms\n    return this\n  }\n\n  /**\n   * Delay the connection by a certain number of ms.\n   *\n   * @param  {integer} ms - Number of milliseconds to wait\n   * @return {Interceptor} - the current interceptor for chaining\n   */\n  delayConnection(ms) {\n    this.delayConnectionInMs = ms\n    return this\n  }\n}\n"]}