{"version":3,"sources":["socket.js"],"names":["require","EventEmitter","debug","module","exports","options","proto","authorized","encrypted","bufferSize","writableLength","writable","readable","pending","destroyed","connecting","_hadError","timeout","ipv6","family","remoteFamily","localAddress","remoteAddress","localPort","remotePort","parseInt","port","address","timeoutMs","fn","once","delayMs","emit","Buffer","from","Math","random","Date","now","toString","err","readableEnded","writableFinished","process","nextTick"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst debug = require('debug')('nock.socket')\n\nmodule.exports = class Socket extends EventEmitter {\n  constructor(options) {\n    super()\n\n    // Pretend this is a TLSSocket\n    if (options.proto === 'https') {\n      // https://github.com/nock/nock/issues/158\n      this.authorized = true\n      // https://github.com/nock/nock/issues/2147\n      this.encrypted = true\n    }\n\n    this.bufferSize = 0\n    this.writableLength = 0\n    this.writable = true\n    this.readable = true\n    this.pending = false\n    this.destroyed = false\n    this.connecting = true\n\n    // Undocumented flag used by ClientRequest to ensure errors aren't double-fired\n    this._hadError = false\n\n    // Maximum allowed delay. 0 means unlimited.\n    this.timeout = 0\n\n    const ipv6 = options.family === 6\n    this.remoteFamily = ipv6 ? 'IPv6' : 'IPv4'\n    this.localAddress = this.remoteAddress = ipv6 ? '::1' : '127.0.0.1'\n    this.localPort = this.remotePort = parseInt(options.port)\n  }\n\n  setNoDelay() {}\n  setKeepAlive() {}\n  resume() {}\n  ref() {}\n  unref() {}\n\n  address() {\n    return {\n      port: this.remotePort,\n      family: this.remoteFamily,\n      address: this.remoteAddress,\n    }\n  }\n\n  setTimeout(timeoutMs, fn) {\n    this.timeout = timeoutMs\n    if (fn) {\n      this.once('timeout', fn)\n    }\n    return this\n  }\n\n  /**\n   * Artificial delay that will trip socket timeouts when appropriate.\n   *\n   * Doesn't actually wait for time to pass.\n   * Timeout events don't necessarily end the request.\n   * While many clients choose to abort the request upon a timeout, Node itself does not.\n   */\n  applyDelay(delayMs) {\n    if (this.timeout && delayMs > this.timeout) {\n      debug('socket timeout')\n      this.emit('timeout')\n    }\n  }\n\n  getPeerCertificate() {\n    return Buffer.from(\n      (Math.random() * 10000 + Date.now()).toString()\n    ).toString('base64')\n  }\n\n  /**\n   * Denotes that no more I/O activity should happen on this socket.\n   *\n   * The implementation in Node if far more complex as it juggles underlying async streams.\n   * For the purposes of Nock, we just need it to set some flags and on the first call\n   * emit a 'close' and optional 'error' event. Both events propagate through the request object.\n   */\n  destroy(err) {\n    if (this.destroyed) {\n      return this\n    }\n\n    debug('socket destroy')\n    this.destroyed = true\n    this.readable = this.writable = false\n    this.readableEnded = this.writableFinished = true\n\n    process.nextTick(() => {\n      if (err) {\n        this._hadError = true\n        this.emit('error', err)\n      }\n      this.emit('close')\n    })\n\n    return this\n  }\n}\n"]}